{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\nvar formatUtil = require(\"../../util/format\");\nvar graphic = require(\"../../util/graphic\");\nvar Model = require(\"../../model/Model\");\nvar _number = require(\"../../util/number\");\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\nvar _symbol = require(\"../../util/symbol\");\nvar createSymbol = _symbol.createSymbol;\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\nvar _vector = require(\"zrender/lib/core/vector\");\nvar v2ApplyTransform = _vector.applyTransform;\nvar _axisHelper = require(\"../../coord/axisHelper\");\nvar shouldShowAllLabels = _axisHelper.shouldShowAllLabels;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line({\n      // Id for animation\n      anid: 'line',\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    }));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true,\n            z2: 11\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n    if (!name) {\n      return;\n    }\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2,\n    // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation,\n      // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isLabelSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: textStyleModel.get('align') || labelLayout.textAlign,\n      textVerticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n    });\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n    this._dumbGroup.add(textEl);\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\nvar makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType,\n    componentIndex: axisModel.componentIndex\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\nvar isLabelSilent = AxisBuilder.isLabelSilent = function (axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n};\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (shouldShowAllLabels(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n    var tickEl = new graphic.Line({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    });\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n  return tickEls;\n}\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor(\n      // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n    axisBuilder._dumbGroup.add(textEl);\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\nvar _default = AxisBuilder;\nmodule.exports = _default;","map":{"version":3,"names":["_util","require","retrieve","defaults","extend","each","formatUtil","graphic","Model","_number","isRadianAroundZero","remRadian","_symbol","createSymbol","matrixUtil","_vector","v2ApplyTransform","applyTransform","_axisHelper","shouldShowAllLabels","PI","Math","AxisBuilder","axisModel","opt","labelOffset","nameDirection","tickDirection","labelDirection","silent","group","Group","dumbGroup","position","slice","rotation","updateTransform","_transform","transform","_dumbGroup","prototype","constructor","hasBuilder","name","builders","add","call","getGroup","axisLine","get","extent","axis","getExtent","matrix","pt1","pt2","lineStyle","lineCap","getModel","getLineStyle","Line","anid","subPixelOptimize","shape","x1","y1","x2","y2","style","strokeContainThreshold","z2","arrows","arrowSize","arrowOffset","symbolWidth","symbolHeight","rotate","offset","r","sqrt","point","index","symbol","stroke","pos","cos","sin","attr","axisTickLabel","tickEls","buildAxisTick","labelEls","buildAxisLabel","fixMinMaxLabelShow","axisName","nameLocation","textStyleModel","gap","gapSignal","isNameLocationCenter","labelLayout","nameRotation","axisNameAvailableWidth","innerTextLayout","endTextLayout","abs","isFinite","textFont","getFont","truncateOpt","ellipsis","maxWidth","nameTruncateMaxWidth","truncatedText","truncateText","minChar","placeholder","tooltipOpt","mainType","formatterParams","componentType","$vars","componentIndex","textEl","Text","__fullText","__truncatedText","isLabelSilent","tooltip","show","content","formatter","setTextStyle","text","textFill","getTextColor","textAlign","textVerticalAlign","eventData","makeAxisEventDataBase","targetType","decomposeTransform","axisRotation","textRotation","direction","rotationDiff","textPosition","textRotate","inverse","onLeft","showMinLabel","showMaxLabel","firstLabel","nextLabel","lastLabel","length","prevLabel","firstTick","nextTick","lastTick","prevTick","ignoreEl","isTwoLabelOverlapped","el","ignore","current","next","firstRect","getBoundingRect","clone","nextRect","mRotationBack","identity","mul","getLocalTransform","intersect","axisBuilder","scale","isBlank","tickModel","lineStyleModel","tickLen","ticksCoords","getTicksCoords","i","tickCoord","coord","tickEl","tickValue","push","axisLabelShow","labelModel","labelMargin","labels","getViewLabels","labelRotation","labelRotate","rawCategoryData","getCategories","triggerEvent","labelItem","formattedLabel","rawLabel","itemLabelModel","textStyle","ecModel","textColor","dataToCoord","getShallow","type","value","_default","module","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/component/axis/AxisBuilder.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar retrieve = _util.retrieve;\nvar defaults = _util.defaults;\nvar extend = _util.extend;\nvar each = _util.each;\n\nvar formatUtil = require(\"../../util/format\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar Model = require(\"../../model/Model\");\n\nvar _number = require(\"../../util/number\");\n\nvar isRadianAroundZero = _number.isRadianAroundZero;\nvar remRadian = _number.remRadian;\n\nvar _symbol = require(\"../../util/symbol\");\n\nvar createSymbol = _symbol.createSymbol;\n\nvar matrixUtil = require(\"zrender/lib/core/matrix\");\n\nvar _vector = require(\"zrender/lib/core/vector\");\n\nvar v2ApplyTransform = _vector.applyTransform;\n\nvar _axisHelper = require(\"../../coord/axisHelper\");\n\nvar shouldShowAllLabels = _axisHelper.shouldShowAllLabels;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar PI = Math.PI;\n/**\n * A final axis is translated and rotated from a \"standard axis\".\n * So opt.position and opt.rotation is required.\n *\n * A standard axis is and axis from [0, 0] to [0, axisExtent[1]],\n * for example: (0, 0) ------------> (0, 50)\n *\n * nameDirection or tickDirection or labelDirection is 1 means tick\n * or label is below the standard axis, whereas is -1 means above\n * the standard axis. labelOffset means offset between label and axis,\n * which is useful when 'onZero', where axisLabel is in the grid and\n * label in outside grid.\n *\n * Tips: like always,\n * positive rotation represents anticlockwise, and negative rotation\n * represents clockwise.\n * The direction of position coordinate is the same as the direction\n * of screen coordinate.\n *\n * Do not need to consider axis 'inverse', which is auto processed by\n * axis extent.\n *\n * @param {module:zrender/container/Group} group\n * @param {Object} axisModel\n * @param {Object} opt Standard axis parameters.\n * @param {Array.<number>} opt.position [x, y]\n * @param {number} opt.rotation by radian\n * @param {number} [opt.nameDirection=1] 1 or -1 Used when nameLocation is 'middle' or 'center'.\n * @param {number} [opt.tickDirection=1] 1 or -1\n * @param {number} [opt.labelDirection=1] 1 or -1\n * @param {number} [opt.labelOffset=0] Usefull when onZero.\n * @param {string} [opt.axisLabelShow] default get from axisModel.\n * @param {string} [opt.axisName] default get from axisModel.\n * @param {number} [opt.axisNameAvailableWidth]\n * @param {number} [opt.labelRotate] by degree, default get from axisModel.\n * @param {number} [opt.strokeContainThreshold] Default label interval when label\n * @param {number} [opt.nameTruncateMaxWidth]\n */\n\nvar AxisBuilder = function (axisModel, opt) {\n  /**\n   * @readOnly\n   */\n  this.opt = opt;\n  /**\n   * @readOnly\n   */\n\n  this.axisModel = axisModel; // Default value\n\n  defaults(opt, {\n    labelOffset: 0,\n    nameDirection: 1,\n    tickDirection: 1,\n    labelDirection: 1,\n    silent: true\n  });\n  /**\n   * @readOnly\n   */\n\n  this.group = new graphic.Group(); // FIXME Not use a seperate text group?\n\n  var dumbGroup = new graphic.Group({\n    position: opt.position.slice(),\n    rotation: opt.rotation\n  }); // this.group.add(dumbGroup);\n  // this._dumbGroup = dumbGroup;\n\n  dumbGroup.updateTransform();\n  this._transform = dumbGroup.transform;\n  this._dumbGroup = dumbGroup;\n};\n\nAxisBuilder.prototype = {\n  constructor: AxisBuilder,\n  hasBuilder: function (name) {\n    return !!builders[name];\n  },\n  add: function (name) {\n    builders[name].call(this);\n  },\n  getGroup: function () {\n    return this.group;\n  }\n};\nvar builders = {\n  /**\n   * @private\n   */\n  axisLine: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n\n    if (!axisModel.get('axisLine.show')) {\n      return;\n    }\n\n    var extent = this.axisModel.axis.getExtent();\n    var matrix = this._transform;\n    var pt1 = [extent[0], 0];\n    var pt2 = [extent[1], 0];\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    }\n\n    var lineStyle = extend({\n      lineCap: 'round'\n    }, axisModel.getModel('axisLine.lineStyle').getLineStyle());\n    this.group.add(new graphic.Line({\n      // Id for animation\n      anid: 'line',\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: lineStyle,\n      strokeContainThreshold: opt.strokeContainThreshold || 5,\n      silent: true,\n      z2: 1\n    }));\n    var arrows = axisModel.get('axisLine.symbol');\n    var arrowSize = axisModel.get('axisLine.symbolSize');\n    var arrowOffset = axisModel.get('axisLine.symbolOffset') || 0;\n\n    if (typeof arrowOffset === 'number') {\n      arrowOffset = [arrowOffset, arrowOffset];\n    }\n\n    if (arrows != null) {\n      if (typeof arrows === 'string') {\n        // Use the same arrow for start and end point\n        arrows = [arrows, arrows];\n      }\n\n      if (typeof arrowSize === 'string' || typeof arrowSize === 'number') {\n        // Use the same size for width and height\n        arrowSize = [arrowSize, arrowSize];\n      }\n\n      var symbolWidth = arrowSize[0];\n      var symbolHeight = arrowSize[1];\n      each([{\n        rotate: opt.rotation + Math.PI / 2,\n        offset: arrowOffset[0],\n        r: 0\n      }, {\n        rotate: opt.rotation - Math.PI / 2,\n        offset: arrowOffset[1],\n        r: Math.sqrt((pt1[0] - pt2[0]) * (pt1[0] - pt2[0]) + (pt1[1] - pt2[1]) * (pt1[1] - pt2[1]))\n      }], function (point, index) {\n        if (arrows[index] !== 'none' && arrows[index] != null) {\n          var symbol = createSymbol(arrows[index], -symbolWidth / 2, -symbolHeight / 2, symbolWidth, symbolHeight, lineStyle.stroke, true); // Calculate arrow position with offset\n\n          var r = point.r + point.offset;\n          var pos = [pt1[0] + r * Math.cos(opt.rotation), pt1[1] - r * Math.sin(opt.rotation)];\n          symbol.attr({\n            rotation: point.rotate,\n            position: pos,\n            silent: true,\n            z2: 11\n          });\n          this.group.add(symbol);\n        }\n      }, this);\n    }\n  },\n\n  /**\n   * @private\n   */\n  axisTickLabel: function () {\n    var axisModel = this.axisModel;\n    var opt = this.opt;\n    var tickEls = buildAxisTick(this, axisModel, opt);\n    var labelEls = buildAxisLabel(this, axisModel, opt);\n    fixMinMaxLabelShow(axisModel, labelEls, tickEls);\n  },\n\n  /**\n   * @private\n   */\n  axisName: function () {\n    var opt = this.opt;\n    var axisModel = this.axisModel;\n    var name = retrieve(opt.axisName, axisModel.get('name'));\n\n    if (!name) {\n      return;\n    }\n\n    var nameLocation = axisModel.get('nameLocation');\n    var nameDirection = opt.nameDirection;\n    var textStyleModel = axisModel.getModel('nameTextStyle');\n    var gap = axisModel.get('nameGap') || 0;\n    var extent = this.axisModel.axis.getExtent();\n    var gapSignal = extent[0] > extent[1] ? -1 : 1;\n    var pos = [nameLocation === 'start' ? extent[0] - gapSignal * gap : nameLocation === 'end' ? extent[1] + gapSignal * gap : (extent[0] + extent[1]) / 2, // 'middle'\n    // Reuse labelOffset.\n    isNameLocationCenter(nameLocation) ? opt.labelOffset + nameDirection * gap : 0];\n    var labelLayout;\n    var nameRotation = axisModel.get('nameRotate');\n\n    if (nameRotation != null) {\n      nameRotation = nameRotation * PI / 180; // To radian.\n    }\n\n    var axisNameAvailableWidth;\n\n    if (isNameLocationCenter(nameLocation)) {\n      labelLayout = innerTextLayout(opt.rotation, nameRotation != null ? nameRotation : opt.rotation, // Adapt to axis.\n      nameDirection);\n    } else {\n      labelLayout = endTextLayout(opt, nameLocation, nameRotation || 0, extent);\n      axisNameAvailableWidth = opt.axisNameAvailableWidth;\n\n      if (axisNameAvailableWidth != null) {\n        axisNameAvailableWidth = Math.abs(axisNameAvailableWidth / Math.sin(labelLayout.rotation));\n        !isFinite(axisNameAvailableWidth) && (axisNameAvailableWidth = null);\n      }\n    }\n\n    var textFont = textStyleModel.getFont();\n    var truncateOpt = axisModel.get('nameTruncate', true) || {};\n    var ellipsis = truncateOpt.ellipsis;\n    var maxWidth = retrieve(opt.nameTruncateMaxWidth, truncateOpt.maxWidth, axisNameAvailableWidth); // FIXME\n    // truncate rich text? (consider performance)\n\n    var truncatedText = ellipsis != null && maxWidth != null ? formatUtil.truncateText(name, maxWidth, textFont, ellipsis, {\n      minChar: 2,\n      placeholder: truncateOpt.placeholder\n    }) : name;\n    var tooltipOpt = axisModel.get('tooltip', true);\n    var mainType = axisModel.mainType;\n    var formatterParams = {\n      componentType: mainType,\n      name: name,\n      $vars: ['name']\n    };\n    formatterParams[mainType + 'Index'] = axisModel.componentIndex;\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'name',\n      __fullText: name,\n      __truncatedText: truncatedText,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: isLabelSilent(axisModel),\n      z2: 1,\n      tooltip: tooltipOpt && tooltipOpt.show ? extend({\n        content: name,\n        formatter: function () {\n          return name;\n        },\n        formatterParams: formatterParams\n      }, tooltipOpt) : null\n    });\n    graphic.setTextStyle(textEl.style, textStyleModel, {\n      text: truncatedText,\n      textFont: textFont,\n      textFill: textStyleModel.getTextColor() || axisModel.get('axisLine.lineStyle.color'),\n      textAlign: textStyleModel.get('align') || labelLayout.textAlign,\n      textVerticalAlign: textStyleModel.get('verticalAlign') || labelLayout.textVerticalAlign\n    });\n\n    if (axisModel.get('triggerEvent')) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisName';\n      textEl.eventData.name = name;\n    } // FIXME\n\n\n    this._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    this.group.add(textEl);\n    textEl.decomposeTransform();\n  }\n};\n\nvar makeAxisEventDataBase = AxisBuilder.makeAxisEventDataBase = function (axisModel) {\n  var eventData = {\n    componentType: axisModel.mainType,\n    componentIndex: axisModel.componentIndex\n  };\n  eventData[axisModel.mainType + 'Index'] = axisModel.componentIndex;\n  return eventData;\n};\n/**\n * @public\n * @static\n * @param {Object} opt\n * @param {number} axisRotation in radian\n * @param {number} textRotation in radian\n * @param {number} direction\n * @return {Object} {\n *  rotation, // according to axis\n *  textAlign,\n *  textVerticalAlign\n * }\n */\n\n\nvar innerTextLayout = AxisBuilder.innerTextLayout = function (axisRotation, textRotation, direction) {\n  var rotationDiff = remRadian(textRotation - axisRotation);\n  var textAlign;\n  var textVerticalAlign;\n\n  if (isRadianAroundZero(rotationDiff)) {\n    // Label is parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI)) {\n    // Label is inverse parallel with axis line.\n    textVerticalAlign = direction > 0 ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff > 0 && rotationDiff < PI) {\n      textAlign = direction > 0 ? 'right' : 'left';\n    } else {\n      textAlign = direction > 0 ? 'left' : 'right';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n};\n\nfunction endTextLayout(opt, textPosition, textRotate, extent) {\n  var rotationDiff = remRadian(textRotate - opt.rotation);\n  var textAlign;\n  var textVerticalAlign;\n  var inverse = extent[0] > extent[1];\n  var onLeft = textPosition === 'start' && !inverse || textPosition !== 'start' && inverse;\n\n  if (isRadianAroundZero(rotationDiff - PI / 2)) {\n    textVerticalAlign = onLeft ? 'bottom' : 'top';\n    textAlign = 'center';\n  } else if (isRadianAroundZero(rotationDiff - PI * 1.5)) {\n    textVerticalAlign = onLeft ? 'top' : 'bottom';\n    textAlign = 'center';\n  } else {\n    textVerticalAlign = 'middle';\n\n    if (rotationDiff < PI * 1.5 && rotationDiff > PI / 2) {\n      textAlign = onLeft ? 'left' : 'right';\n    } else {\n      textAlign = onLeft ? 'right' : 'left';\n    }\n  }\n\n  return {\n    rotation: rotationDiff,\n    textAlign: textAlign,\n    textVerticalAlign: textVerticalAlign\n  };\n}\n\nvar isLabelSilent = AxisBuilder.isLabelSilent = function (axisModel) {\n  var tooltipOpt = axisModel.get('tooltip');\n  return axisModel.get('silent') // Consider mouse cursor, add these restrictions.\n  || !(axisModel.get('triggerEvent') || tooltipOpt && tooltipOpt.show);\n};\n\nfunction fixMinMaxLabelShow(axisModel, labelEls, tickEls) {\n  if (shouldShowAllLabels(axisModel.axis)) {\n    return;\n  } // If min or max are user set, we need to check\n  // If the tick on min(max) are overlap on their neighbour tick\n  // If they are overlapped, we need to hide the min(max) tick label\n\n\n  var showMinLabel = axisModel.get('axisLabel.showMinLabel');\n  var showMaxLabel = axisModel.get('axisLabel.showMaxLabel'); // FIXME\n  // Have not consider onBand yet, where tick els is more than label els.\n\n  labelEls = labelEls || [];\n  tickEls = tickEls || [];\n  var firstLabel = labelEls[0];\n  var nextLabel = labelEls[1];\n  var lastLabel = labelEls[labelEls.length - 1];\n  var prevLabel = labelEls[labelEls.length - 2];\n  var firstTick = tickEls[0];\n  var nextTick = tickEls[1];\n  var lastTick = tickEls[tickEls.length - 1];\n  var prevTick = tickEls[tickEls.length - 2];\n\n  if (showMinLabel === false) {\n    ignoreEl(firstLabel);\n    ignoreEl(firstTick);\n  } else if (isTwoLabelOverlapped(firstLabel, nextLabel)) {\n    if (showMinLabel) {\n      ignoreEl(nextLabel);\n      ignoreEl(nextTick);\n    } else {\n      ignoreEl(firstLabel);\n      ignoreEl(firstTick);\n    }\n  }\n\n  if (showMaxLabel === false) {\n    ignoreEl(lastLabel);\n    ignoreEl(lastTick);\n  } else if (isTwoLabelOverlapped(prevLabel, lastLabel)) {\n    if (showMaxLabel) {\n      ignoreEl(prevLabel);\n      ignoreEl(prevTick);\n    } else {\n      ignoreEl(lastLabel);\n      ignoreEl(lastTick);\n    }\n  }\n}\n\nfunction ignoreEl(el) {\n  el && (el.ignore = true);\n}\n\nfunction isTwoLabelOverlapped(current, next, labelLayout) {\n  // current and next has the same rotation.\n  var firstRect = current && current.getBoundingRect().clone();\n  var nextRect = next && next.getBoundingRect().clone();\n\n  if (!firstRect || !nextRect) {\n    return;\n  } // When checking intersect of two rotated labels, we use mRotationBack\n  // to avoid that boundingRect is enlarge when using `boundingRect.applyTransform`.\n\n\n  var mRotationBack = matrixUtil.identity([]);\n  matrixUtil.rotate(mRotationBack, mRotationBack, -current.rotation);\n  firstRect.applyTransform(matrixUtil.mul([], mRotationBack, current.getLocalTransform()));\n  nextRect.applyTransform(matrixUtil.mul([], mRotationBack, next.getLocalTransform()));\n  return firstRect.intersect(nextRect);\n}\n\nfunction isNameLocationCenter(nameLocation) {\n  return nameLocation === 'middle' || nameLocation === 'center';\n}\n\nfunction buildAxisTick(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n\n  if (!axisModel.get('axisTick.show') || axis.scale.isBlank()) {\n    return;\n  }\n\n  var tickModel = axisModel.getModel('axisTick');\n  var lineStyleModel = tickModel.getModel('lineStyle');\n  var tickLen = tickModel.get('length');\n  var ticksCoords = axis.getTicksCoords();\n  var pt1 = [];\n  var pt2 = [];\n  var matrix = axisBuilder._transform;\n  var tickEls = [];\n\n  for (var i = 0; i < ticksCoords.length; i++) {\n    var tickCoord = ticksCoords[i].coord;\n    pt1[0] = tickCoord;\n    pt1[1] = 0;\n    pt2[0] = tickCoord;\n    pt2[1] = opt.tickDirection * tickLen;\n\n    if (matrix) {\n      v2ApplyTransform(pt1, pt1, matrix);\n      v2ApplyTransform(pt2, pt2, matrix);\n    } // Tick line, Not use group transform to have better line draw\n\n\n    var tickEl = new graphic.Line({\n      // Id for animation\n      anid: 'tick_' + ticksCoords[i].tickValue,\n      subPixelOptimize: true,\n      shape: {\n        x1: pt1[0],\n        y1: pt1[1],\n        x2: pt2[0],\n        y2: pt2[1]\n      },\n      style: defaults(lineStyleModel.getLineStyle(), {\n        stroke: axisModel.get('axisLine.lineStyle.color')\n      }),\n      z2: 2,\n      silent: true\n    });\n    axisBuilder.group.add(tickEl);\n    tickEls.push(tickEl);\n  }\n\n  return tickEls;\n}\n\nfunction buildAxisLabel(axisBuilder, axisModel, opt) {\n  var axis = axisModel.axis;\n  var show = retrieve(opt.axisLabelShow, axisModel.get('axisLabel.show'));\n\n  if (!show || axis.scale.isBlank()) {\n    return;\n  }\n\n  var labelModel = axisModel.getModel('axisLabel');\n  var labelMargin = labelModel.get('margin');\n  var labels = axis.getViewLabels(); // Special label rotate.\n\n  var labelRotation = (retrieve(opt.labelRotate, labelModel.get('rotate')) || 0) * PI / 180;\n  var labelLayout = innerTextLayout(opt.rotation, labelRotation, opt.labelDirection);\n  var rawCategoryData = axisModel.getCategories && axisModel.getCategories(true);\n  var labelEls = [];\n  var silent = isLabelSilent(axisModel);\n  var triggerEvent = axisModel.get('triggerEvent');\n  each(labels, function (labelItem, index) {\n    var tickValue = labelItem.tickValue;\n    var formattedLabel = labelItem.formattedLabel;\n    var rawLabel = labelItem.rawLabel;\n    var itemLabelModel = labelModel;\n\n    if (rawCategoryData && rawCategoryData[tickValue] && rawCategoryData[tickValue].textStyle) {\n      itemLabelModel = new Model(rawCategoryData[tickValue].textStyle, labelModel, axisModel.ecModel);\n    }\n\n    var textColor = itemLabelModel.getTextColor() || axisModel.get('axisLine.lineStyle.color');\n    var tickCoord = axis.dataToCoord(tickValue);\n    var pos = [tickCoord, opt.labelOffset + opt.labelDirection * labelMargin];\n    var textEl = new graphic.Text({\n      // Id for animation\n      anid: 'label_' + tickValue,\n      position: pos,\n      rotation: labelLayout.rotation,\n      silent: silent,\n      z2: 10\n    });\n    graphic.setTextStyle(textEl.style, itemLabelModel, {\n      text: formattedLabel,\n      textAlign: itemLabelModel.getShallow('align', true) || labelLayout.textAlign,\n      textVerticalAlign: itemLabelModel.getShallow('verticalAlign', true) || itemLabelModel.getShallow('baseline', true) || labelLayout.textVerticalAlign,\n      textFill: typeof textColor === 'function' ? textColor( // (1) In category axis with data zoom, tick is not the original\n      // index of axis.data. So tick should not be exposed to user\n      // in category axis.\n      // (2) Compatible with previous version, which always use formatted label as\n      // input. But in interval scale the formatted label is like '223,445', which\n      // maked user repalce ','. So we modify it to return original val but remain\n      // it as 'string' to avoid error in replacing.\n      axis.type === 'category' ? rawLabel : axis.type === 'value' ? tickValue + '' : tickValue, index) : textColor\n    }); // Pack data for mouse event\n\n    if (triggerEvent) {\n      textEl.eventData = makeAxisEventDataBase(axisModel);\n      textEl.eventData.targetType = 'axisLabel';\n      textEl.eventData.value = rawLabel;\n    } // FIXME\n\n\n    axisBuilder._dumbGroup.add(textEl);\n\n    textEl.updateTransform();\n    labelEls.push(textEl);\n    axisBuilder.group.add(textEl);\n    textEl.decomposeTransform();\n  });\n  return labelEls;\n}\n\nvar _default = AxisBuilder;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}