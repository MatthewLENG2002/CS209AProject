{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\nvar __DEV__ = _config.__DEV__;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar OrdinalScale = require(\"../scale/Ordinal\");\nvar IntervalScale = require(\"../scale/Interval\");\nvar Scale = require(\"../scale/Scale\");\nvar numberUtil = require(\"../util/number\");\nvar _barGrid = require(\"../layout/barGrid\");\nvar prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;\nvar makeColumnLayout = _barGrid.makeColumnLayout;\nvar retrieveColumnLayout = _barGrid.retrieveColumnLayout;\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\nrequire(\"../scale/Time\");\nrequire(\"../scale/Log\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n  if (scaleType === 'ordinal') {\n    axisDataLen = model.getCategories().length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || scaleType === 'ordinal' && !scale.getOrdinalMeta().categories.length); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  } // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n\n  var ecModel = model.ecModel;\n  if (ecModel && scaleType === 'time'\n  /*|| scaleType === 'interval' */) {\n    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;\n    });\n    if (isBaseAxisAndHasBarSeries) {\n      // Calculate placement of bars on axis\n      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow\n\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n  return [min, max];\n}\nfunction adjustScaleForOverflow(min, max, model, barWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow\n\n  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow; // Calulate required buffer based on old range and overflow\n\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n}\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @return {Function} Label formatter function.\n *         param: {number} tickValue,\n *         param: {number} idx, the index in all ticks.\n *                         If category axis, this param is not requied.\n *         return: {string} label string.\n */\n\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        // For category axis, get raw value; for numeric axis,\n        // get foramtted label like '1,333,444'.\n        val = axis.scale.getLabel(val);\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n    return labelFormatter;\n  } else if (typeof labelFormatter === 'function') {\n    return function (tickValue, idx) {\n      // The original intention of `idx` is \"the index of the tick in all ticks\".\n      // But the previous implementation of category axis do not consider the\n      // `axisLabel.interval`, which cause that, for example, the `interval` is\n      // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n      // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n      // the definition here for back compatibility.\n      if (categoryTickStart != null) {\n        idx = tickValue - categoryTickStart;\n      }\n      return labelFormatter(getAxisRawValue(axis, tickValue), idx);\n    };\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.\n */\n\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n  if (!axisModel.get('axisLabel.show') || scale.isBlank()) {\n    return;\n  }\n  var isCategory = axis.type === 'category';\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.\n\n  if (isCategory) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1; // Simple optimization for large amount of labels\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n  for (var i = 0; i < tickCount; i += step) {\n    var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;\n    var label = labelFormatter(tickValue);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n  return rect;\n}\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\n * @param {module:echarts/src/model/Model} model axisLabelModel or axisTickModel\n * @return {number|String} Can be null|'auto'|number|function\n */\n\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\n * Set `categoryInterval` as 0 implicitly indicates that\n * show all labels reguardless of overlap.\n * @param {Object} axis axisModel.axis\n * @return {boolean}\n */\n\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.makeLabelFormatter = makeLabelFormatter;\nexports.getAxisRawValue = getAxisRawValue;\nexports.estimateLabelUnionRect = estimateLabelUnionRect;\nexports.getOptionCategoryInterval = getOptionCategoryInterval;\nexports.shouldShowAllLabels = shouldShowAllLabels;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","OrdinalScale","IntervalScale","Scale","numberUtil","_barGrid","prepareLayoutBarSeries","makeColumnLayout","retrieveColumnLayout","BoundingRect","getScaleExtent","scale","model","scaleType","type","min","getMin","max","getMax","fixMin","fixMax","originalExtent","getExtent","axisDataLen","boundaryGap","span","getCategories","length","get","isArray","parsePercent","Math","abs","NaN","isFinite","setBlank","eqNaN","getOrdinalMeta","categories","getNeedCrossZero","ecModel","barSeriesModels","isBaseAxisAndHasBarSeries","each","seriesModel","getBaseAxis","axis","barWidthAndOffset","adjustedScale","adjustScaleForOverflow","axisExtent","axisLength","barsOnCurrentAxis","undefined","minOverflow","Infinity","item","offset","maxOverflow","width","totalOverFlow","oldRange","oldRangePercentOfNew","overflowBuffer","niceScaleExtent","extent","splitNumber","base","setExtent","niceExtent","minInterval","maxInterval","interval","setInterval","createScaleByModel","axisType","getClass","create","ifAxisCrossZero","dataExtent","makeLabelFormatter","labelFormatter","getLabelModel","categoryTickStart","tpl","val","getLabel","replace","tickValue","idx","getAxisRawValue","tick","value","estimateLabelUnionRect","axisModel","isBlank","isCategory","realNumberScaleTicks","tickCount","categoryScaleExtent","count","getTicks","axisLabelModel","rect","step","ceil","i","label","unrotatedSingleRect","getTextRect","singleRect","rotateTextRect","union","textRect","rotate","rotateRadians","PI","boundingBox","plain","beforeWidth","beforeHeight","height","afterWidth","cos","sin","afterHeight","rotatedRect","x","y","getOptionCategoryInterval","shouldShowAllLabels","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/coord/axisHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar OrdinalScale = require(\"../scale/Ordinal\");\n\nvar IntervalScale = require(\"../scale/Interval\");\n\nvar Scale = require(\"../scale/Scale\");\n\nvar numberUtil = require(\"../util/number\");\n\nvar _barGrid = require(\"../layout/barGrid\");\n\nvar prepareLayoutBarSeries = _barGrid.prepareLayoutBarSeries;\nvar makeColumnLayout = _barGrid.makeColumnLayout;\nvar retrieveColumnLayout = _barGrid.retrieveColumnLayout;\n\nvar BoundingRect = require(\"zrender/lib/core/BoundingRect\");\n\nrequire(\"../scale/Time\");\n\nrequire(\"../scale/Log\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/**\n * Get axis scale extent before niced.\n * Item of returned array can only be number (including Infinity and NaN).\n */\nfunction getScaleExtent(scale, model) {\n  var scaleType = scale.type;\n  var min = model.getMin();\n  var max = model.getMax();\n  var fixMin = min != null;\n  var fixMax = max != null;\n  var originalExtent = scale.getExtent();\n  var axisDataLen;\n  var boundaryGap;\n  var span;\n\n  if (scaleType === 'ordinal') {\n    axisDataLen = model.getCategories().length;\n  } else {\n    boundaryGap = model.get('boundaryGap');\n\n    if (!zrUtil.isArray(boundaryGap)) {\n      boundaryGap = [boundaryGap || 0, boundaryGap || 0];\n    }\n\n    if (typeof boundaryGap[0] === 'boolean') {\n      boundaryGap = [0, 0];\n    }\n\n    boundaryGap[0] = numberUtil.parsePercent(boundaryGap[0], 1);\n    boundaryGap[1] = numberUtil.parsePercent(boundaryGap[1], 1);\n    span = originalExtent[1] - originalExtent[0] || Math.abs(originalExtent[0]);\n  } // Notice: When min/max is not set (that is, when there are null/undefined,\n  // which is the most common case), these cases should be ensured:\n  // (1) For 'ordinal', show all axis.data.\n  // (2) For others:\n  //      + `boundaryGap` is applied (if min/max set, boundaryGap is\n  //      disabled).\n  //      + If `needCrossZero`, min/max should be zero, otherwise, min/max should\n  //      be the result that originalExtent enlarged by boundaryGap.\n  // (3) If no data, it should be ensured that `scale.setBlank` is set.\n  // FIXME\n  // (1) When min/max is 'dataMin' or 'dataMax', should boundaryGap be able to used?\n  // (2) When `needCrossZero` and all data is positive/negative, should it be ensured\n  // that the results processed by boundaryGap are positive/negative?\n\n\n  if (min == null) {\n    min = scaleType === 'ordinal' ? axisDataLen ? 0 : NaN : originalExtent[0] - boundaryGap[0] * span;\n  }\n\n  if (max == null) {\n    max = scaleType === 'ordinal' ? axisDataLen ? axisDataLen - 1 : NaN : originalExtent[1] + boundaryGap[1] * span;\n  }\n\n  if (min === 'dataMin') {\n    min = originalExtent[0];\n  } else if (typeof min === 'function') {\n    min = min({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  if (max === 'dataMax') {\n    max = originalExtent[1];\n  } else if (typeof max === 'function') {\n    max = max({\n      min: originalExtent[0],\n      max: originalExtent[1]\n    });\n  }\n\n  (min == null || !isFinite(min)) && (min = NaN);\n  (max == null || !isFinite(max)) && (max = NaN);\n  scale.setBlank(zrUtil.eqNaN(min) || zrUtil.eqNaN(max) || scaleType === 'ordinal' && !scale.getOrdinalMeta().categories.length); // Evaluate if axis needs cross zero\n\n  if (model.getNeedCrossZero()) {\n    // Axis is over zero and min is not set\n    if (min > 0 && max > 0 && !fixMin) {\n      min = 0;\n    } // Axis is under zero and max is not set\n\n\n    if (min < 0 && max < 0 && !fixMax) {\n      max = 0;\n    }\n  } // If bars are placed on a base axis of type time or interval account for axis boundary overflow and current axis\n  // is base axis\n  // FIXME\n  // (1) Consider support value axis, where below zero and axis `onZero` should be handled properly.\n  // (2) Refactor the logic with `barGrid`. Is it not need to `makeBarWidthAndOffsetInfo` twice with different extent?\n  //     Should not depend on series type `bar`?\n  // (3) Fix that might overlap when using dataZoom.\n  // (4) Consider other chart types using `barGrid`?\n  // See #6728, #4862, `test/bar-overflow-time-plot.html`\n\n\n  var ecModel = model.ecModel;\n\n  if (ecModel && scaleType === 'time'\n  /*|| scaleType === 'interval' */\n  ) {\n    var barSeriesModels = prepareLayoutBarSeries('bar', ecModel);\n    var isBaseAxisAndHasBarSeries;\n    zrUtil.each(barSeriesModels, function (seriesModel) {\n      isBaseAxisAndHasBarSeries |= seriesModel.getBaseAxis() === model.axis;\n    });\n\n    if (isBaseAxisAndHasBarSeries) {\n      // Calculate placement of bars on axis\n      var barWidthAndOffset = makeColumnLayout(barSeriesModels); // Adjust axis min and max to account for overflow\n\n      var adjustedScale = adjustScaleForOverflow(min, max, model, barWidthAndOffset);\n      min = adjustedScale.min;\n      max = adjustedScale.max;\n    }\n  }\n\n  return [min, max];\n}\n\nfunction adjustScaleForOverflow(min, max, model, barWidthAndOffset) {\n  // Get Axis Length\n  var axisExtent = model.axis.getExtent();\n  var axisLength = axisExtent[1] - axisExtent[0]; // Get bars on current base axis and calculate min and max overflow\n\n  var barsOnCurrentAxis = retrieveColumnLayout(barWidthAndOffset, model.axis);\n\n  if (barsOnCurrentAxis === undefined) {\n    return {\n      min: min,\n      max: max\n    };\n  }\n\n  var minOverflow = Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    minOverflow = Math.min(item.offset, minOverflow);\n  });\n  var maxOverflow = -Infinity;\n  zrUtil.each(barsOnCurrentAxis, function (item) {\n    maxOverflow = Math.max(item.offset + item.width, maxOverflow);\n  });\n  minOverflow = Math.abs(minOverflow);\n  maxOverflow = Math.abs(maxOverflow);\n  var totalOverFlow = minOverflow + maxOverflow; // Calulate required buffer based on old range and overflow\n\n  var oldRange = max - min;\n  var oldRangePercentOfNew = 1 - (minOverflow + maxOverflow) / axisLength;\n  var overflowBuffer = oldRange / oldRangePercentOfNew - oldRange;\n  max += overflowBuffer * (maxOverflow / totalOverFlow);\n  min -= overflowBuffer * (minOverflow / totalOverFlow);\n  return {\n    min: min,\n    max: max\n  };\n}\n\nfunction niceScaleExtent(scale, model) {\n  var extent = getScaleExtent(scale, model);\n  var fixMin = model.getMin() != null;\n  var fixMax = model.getMax() != null;\n  var splitNumber = model.get('splitNumber');\n\n  if (scale.type === 'log') {\n    scale.base = model.get('logBase');\n  }\n\n  var scaleType = scale.type;\n  scale.setExtent(extent[0], extent[1]);\n  scale.niceExtent({\n    splitNumber: splitNumber,\n    fixMin: fixMin,\n    fixMax: fixMax,\n    minInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('minInterval') : null,\n    maxInterval: scaleType === 'interval' || scaleType === 'time' ? model.get('maxInterval') : null\n  }); // If some one specified the min, max. And the default calculated interval\n  // is not good enough. He can specify the interval. It is often appeared\n  // in angle axis with angle 0 - 360. Interval calculated in interval scale is hard\n  // to be 60.\n  // FIXME\n\n  var interval = model.get('interval');\n\n  if (interval != null) {\n    scale.setInterval && scale.setInterval(interval);\n  }\n}\n/**\n * @param {module:echarts/model/Model} model\n * @param {string} [axisType] Default retrieve from model.type\n * @return {module:echarts/scale/*}\n */\n\n\nfunction createScaleByModel(model, axisType) {\n  axisType = axisType || model.get('type');\n\n  if (axisType) {\n    switch (axisType) {\n      // Buildin scale\n      case 'category':\n        return new OrdinalScale(model.getOrdinalMeta ? model.getOrdinalMeta() : model.getCategories(), [Infinity, -Infinity]);\n\n      case 'value':\n        return new IntervalScale();\n      // Extended scale, like time and log\n\n      default:\n        return (Scale.getClass(axisType) || IntervalScale).create(model);\n    }\n  }\n}\n/**\n * Check if the axis corss 0\n */\n\n\nfunction ifAxisCrossZero(axis) {\n  var dataExtent = axis.scale.getExtent();\n  var min = dataExtent[0];\n  var max = dataExtent[1];\n  return !(min > 0 && max > 0 || min < 0 && max < 0);\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @return {Function} Label formatter function.\n *         param: {number} tickValue,\n *         param: {number} idx, the index in all ticks.\n *                         If category axis, this param is not requied.\n *         return: {string} label string.\n */\n\n\nfunction makeLabelFormatter(axis) {\n  var labelFormatter = axis.getLabelModel().get('formatter');\n  var categoryTickStart = axis.type === 'category' ? axis.scale.getExtent()[0] : null;\n\n  if (typeof labelFormatter === 'string') {\n    labelFormatter = function (tpl) {\n      return function (val) {\n        // For category axis, get raw value; for numeric axis,\n        // get foramtted label like '1,333,444'.\n        val = axis.scale.getLabel(val);\n        return tpl.replace('{value}', val != null ? val : '');\n      };\n    }(labelFormatter); // Consider empty array\n\n\n    return labelFormatter;\n  } else if (typeof labelFormatter === 'function') {\n    return function (tickValue, idx) {\n      // The original intention of `idx` is \"the index of the tick in all ticks\".\n      // But the previous implementation of category axis do not consider the\n      // `axisLabel.interval`, which cause that, for example, the `interval` is\n      // `1`, then the ticks \"name5\", \"name7\", \"name9\" are displayed, where the\n      // corresponding `idx` are `0`, `2`, `4`, but not `0`, `1`, `2`. So we keep\n      // the definition here for back compatibility.\n      if (categoryTickStart != null) {\n        idx = tickValue - categoryTickStart;\n      }\n\n      return labelFormatter(getAxisRawValue(axis, tickValue), idx);\n    };\n  } else {\n    return function (tick) {\n      return axis.scale.getLabel(tick);\n    };\n  }\n}\n\nfunction getAxisRawValue(axis, value) {\n  // In category axis with data zoom, tick is not the original\n  // index of axis.data. So tick should not be exposed to user\n  // in category axis.\n  return axis.type === 'category' ? axis.scale.getLabel(value) : value;\n}\n/**\n * @param {module:echarts/coord/Axis} axis\n * @return {module:zrender/core/BoundingRect} Be null/undefined if no labels.\n */\n\n\nfunction estimateLabelUnionRect(axis) {\n  var axisModel = axis.model;\n  var scale = axis.scale;\n\n  if (!axisModel.get('axisLabel.show') || scale.isBlank()) {\n    return;\n  }\n\n  var isCategory = axis.type === 'category';\n  var realNumberScaleTicks;\n  var tickCount;\n  var categoryScaleExtent = scale.getExtent(); // Optimize for large category data, avoid call `getTicks()`.\n\n  if (isCategory) {\n    tickCount = scale.count();\n  } else {\n    realNumberScaleTicks = scale.getTicks();\n    tickCount = realNumberScaleTicks.length;\n  }\n\n  var axisLabelModel = axis.getLabelModel();\n  var labelFormatter = makeLabelFormatter(axis);\n  var rect;\n  var step = 1; // Simple optimization for large amount of labels\n\n  if (tickCount > 40) {\n    step = Math.ceil(tickCount / 40);\n  }\n\n  for (var i = 0; i < tickCount; i += step) {\n    var tickValue = realNumberScaleTicks ? realNumberScaleTicks[i] : categoryScaleExtent[0] + i;\n    var label = labelFormatter(tickValue);\n    var unrotatedSingleRect = axisLabelModel.getTextRect(label);\n    var singleRect = rotateTextRect(unrotatedSingleRect, axisLabelModel.get('rotate') || 0);\n    rect ? rect.union(singleRect) : rect = singleRect;\n  }\n\n  return rect;\n}\n\nfunction rotateTextRect(textRect, rotate) {\n  var rotateRadians = rotate * Math.PI / 180;\n  var boundingBox = textRect.plain();\n  var beforeWidth = boundingBox.width;\n  var beforeHeight = boundingBox.height;\n  var afterWidth = beforeWidth * Math.cos(rotateRadians) + beforeHeight * Math.sin(rotateRadians);\n  var afterHeight = beforeWidth * Math.sin(rotateRadians) + beforeHeight * Math.cos(rotateRadians);\n  var rotatedRect = new BoundingRect(boundingBox.x, boundingBox.y, afterWidth, afterHeight);\n  return rotatedRect;\n}\n/**\n * @param {module:echarts/src/model/Model} model axisLabelModel or axisTickModel\n * @return {number|String} Can be null|'auto'|number|function\n */\n\n\nfunction getOptionCategoryInterval(model) {\n  var interval = model.get('interval');\n  return interval == null ? 'auto' : interval;\n}\n/**\n * Set `categoryInterval` as 0 implicitly indicates that\n * show all labels reguardless of overlap.\n * @param {Object} axis axisModel.axis\n * @return {boolean}\n */\n\n\nfunction shouldShowAllLabels(axis) {\n  return axis.type === 'category' && getOptionCategoryInterval(axis.getLabelModel()) === 0;\n}\n\nexports.getScaleExtent = getScaleExtent;\nexports.niceScaleExtent = niceScaleExtent;\nexports.createScaleByModel = createScaleByModel;\nexports.ifAxisCrossZero = ifAxisCrossZero;\nexports.makeLabelFormatter = makeLabelFormatter;\nexports.getAxisRawValue = getAxisRawValue;\nexports.estimateLabelUnionRect = estimateLabelUnionRect;\nexports.getOptionCategoryInterval = getOptionCategoryInterval;\nexports.shouldShowAllLabels = shouldShowAllLabels;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}