{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\nvar __DEV__ = _config.__DEV__;\nvar _model = require(\"../../util/model\");\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\nvar _referHelper = require(\"../../model/referHelper\");\nvar getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;\nvar _util = require(\"zrender/lib/core/util\");\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\nvar Source = require(\"../Source\");\nvar _sourceType = require(\"./sourceType\");\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.\n\n  var encodeDefine = seriesOption.encode;\n  if (!encodeDefine && datasetModel) {\n    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);\n  }\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    encodeDefine: encodeDefine\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n  var dimensionsDetectCount;\n  var startIndex;\n  var findPotentialName;\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n      findPotentialName = true;\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      findPotentialName = true;\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n  var potentialNameDimIndex;\n  if (findPotentialName) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount,\n    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n    var exist = nameMap.get(item.name);\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n    return item;\n  });\n}\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n} // ??? TODO merge to completedimensions, where also has\n// default encode making logic. And the default rule\n// should depends on series? consider 'map'.\n\nfunction makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {\n  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);\n  var encode = {}; // var encodeTooltip = [];\n  // var encodeLabel = [];\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.\n  // Consider the case: 'map' series is based on geo coordSys,\n  // 'graph', 'heatmap' can be based on cartesian. But can not\n  // give default rule simply here.\n\n  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);\n  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data\n  // dimension as the \"value\" dimension, or other default\n  // processes respectively.\n\n  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {\n    var ecModel = seriesModel.ecModel;\n    var datasetMap = inner(ecModel).datasetMap;\n    var key = datasetModel.uid + '_' + seriesLayoutBy;\n    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n      categoryWayDim: 1,\n      valueWayDim: 0\n    }); // TODO\n    // Auto detect first time axis and do arrangement.\n\n    each(coordSysDefine.coordSysDims, function (coordDim) {\n      // In value way.\n      if (coordSysDefine.firstCategoryDimIndex == null) {\n        var dataDim = datasetRecord.valueWayDim++;\n        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?\n        // especially when encode x y specified.\n        // consider: when mutiple series share one dimension\n        // category axis, series name should better use\n        // the other dimsion name. On the other hand, use\n        // both dimensions name.\n\n        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n      } // In category way, category axis.\n      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {\n        encode[coordDim] = 0;\n        encodeItemName.push(0);\n      } // In category way, non-category axis.\n      else {\n        var dataDim = datasetRecord.categoryWayDim++;\n        encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n\n        encodeSeriesName.push(dataDim);\n      }\n    });\n  } // Do not make a complex rule! Hard to code maintain and not necessary.\n  // ??? TODO refactor: provide by series itself.\n  // [{name: ..., value: ...}, ...] like:\n  else if (nSeriesMap.get(seriesType) != null) {\n    // Find the first not ordinal. (5 is an experience value)\n    var firstNotOrdinal;\n    for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {\n      if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {\n        firstNotOrdinal = i;\n      }\n    }\n    if (firstNotOrdinal != null) {\n      encode.value = firstNotOrdinal;\n      var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.\n      // So we dont set encodeLabel here.\n\n      encodeSeriesName.push(nameDimIndex);\n      encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);\n    }\n  } // encodeTooltip.length && (encode.tooltip = encodeTooltip);\n  // encodeLabel.length && (encode.label = encodeLabel);\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {boolean} Whether ordinal.\n */\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n  if (isTypedArray(data)) {\n    return false;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n  var dimName;\n  if (dimensionsDefine) {\n    dimName = dimensionsDefine[dimIndex];\n    dimName = isObject(dimName) ? dimName.name : dimName;\n  }\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return;\n    }\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return;\n    }\n    var sample = data[dimName];\n    if (!sample || isTypedArray(sample)) {\n      return false;\n    }\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n      if (!isArray(val)) {\n        return false;\n      }\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n  function detectValue(val) {\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n    if (val != null && isFinite(val) && val !== '') {\n      return false;\n    } else if (isString(val) && val !== '-') {\n      return true;\n    }\n  }\n  return false;\n}\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.guessOrdinal = guessOrdinal;","map":{"version":3,"names":["_config","require","__DEV__","_model","makeInner","getDataItemValue","_referHelper","getCoordSysDefineBySeries","_util","createHashMap","each","map","isArray","isString","isObject","isTypedArray","isArrayLike","extend","assert","Source","_sourceType","SOURCE_FORMAT_ORIGINAL","SOURCE_FORMAT_ARRAY_ROWS","SOURCE_FORMAT_OBJECT_ROWS","SOURCE_FORMAT_KEYED_COLUMNS","SOURCE_FORMAT_UNKNOWN","SOURCE_FORMAT_TYPED_ARRAY","SERIES_LAYOUT_BY_ROW","inner","detectSourceFormat","datasetModel","data","option","source","sourceFormat","length","i","len","item","key","hasOwnProperty","Error","getSource","seriesModel","resetSourceDefaulter","ecModel","datasetMap","prepareSource","seriesOption","fromDataset","seriesLayoutBy","sourceHeader","dimensionsDefine","dimensions","getDatasetModel","datasetOption","completeResult","completeBySourceData","encodeDefine","encode","makeDefaultEncode","startIndex","dimensionsDetectCount","normalizeDimensionsDefine","findPotentialName","arrayRowsTravelFirst","val","index","objectRowsCollectDimensions","colArr","push","value0","potentialNameDimIndex","dim","idx","name","nameMap","displayName","exist","get","set","count","cb","maxLoop","Infinity","firstIndex","obj","value","coordSysDefine","encodeItemName","encodeSeriesName","seriesType","subType","nSeriesMap","cSeriesMap","uid","datasetRecord","categoryWayDim","valueWayDim","coordSysDims","coordDim","firstCategoryDimIndex","dataDim","categoryAxisMap","firstNotOrdinal","doGuessOrdinal","nameDimIndex","Math","max","itemName","seriesName","thisData","getComponent","datasetIndex","guessOrdinal","dimIndex","result","dimName","sample","detectValue","row","isFinite","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/data/helper/sourceHelper.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar _model = require(\"../../util/model\");\n\nvar makeInner = _model.makeInner;\nvar getDataItemValue = _model.getDataItemValue;\n\nvar _referHelper = require(\"../../model/referHelper\");\n\nvar getCoordSysDefineBySeries = _referHelper.getCoordSysDefineBySeries;\n\nvar _util = require(\"zrender/lib/core/util\");\n\nvar createHashMap = _util.createHashMap;\nvar each = _util.each;\nvar map = _util.map;\nvar isArray = _util.isArray;\nvar isString = _util.isString;\nvar isObject = _util.isObject;\nvar isTypedArray = _util.isTypedArray;\nvar isArrayLike = _util.isArrayLike;\nvar extend = _util.extend;\nvar assert = _util.assert;\n\nvar Source = require(\"../Source\");\n\nvar _sourceType = require(\"./sourceType\");\n\nvar SOURCE_FORMAT_ORIGINAL = _sourceType.SOURCE_FORMAT_ORIGINAL;\nvar SOURCE_FORMAT_ARRAY_ROWS = _sourceType.SOURCE_FORMAT_ARRAY_ROWS;\nvar SOURCE_FORMAT_OBJECT_ROWS = _sourceType.SOURCE_FORMAT_OBJECT_ROWS;\nvar SOURCE_FORMAT_KEYED_COLUMNS = _sourceType.SOURCE_FORMAT_KEYED_COLUMNS;\nvar SOURCE_FORMAT_UNKNOWN = _sourceType.SOURCE_FORMAT_UNKNOWN;\nvar SOURCE_FORMAT_TYPED_ARRAY = _sourceType.SOURCE_FORMAT_TYPED_ARRAY;\nvar SERIES_LAYOUT_BY_ROW = _sourceType.SERIES_LAYOUT_BY_ROW;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar inner = makeInner();\n/**\n * @see {module:echarts/data/Source}\n * @param {module:echarts/component/dataset/DatasetModel} datasetModel\n * @return {string} sourceFormat\n */\n\nfunction detectSourceFormat(datasetModel) {\n  var data = datasetModel.option.source;\n  var sourceFormat = SOURCE_FORMAT_UNKNOWN;\n\n  if (isTypedArray(data)) {\n    sourceFormat = SOURCE_FORMAT_TYPED_ARRAY;\n  } else if (isArray(data)) {\n    // FIXME Whether tolerate null in top level array?\n    if (data.length === 0) {\n      sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n    }\n\n    for (var i = 0, len = data.length; i < len; i++) {\n      var item = data[i];\n\n      if (item == null) {\n        continue;\n      } else if (isArray(item)) {\n        sourceFormat = SOURCE_FORMAT_ARRAY_ROWS;\n        break;\n      } else if (isObject(item)) {\n        sourceFormat = SOURCE_FORMAT_OBJECT_ROWS;\n        break;\n      }\n    }\n  } else if (isObject(data)) {\n    for (var key in data) {\n      if (data.hasOwnProperty(key) && isArrayLike(data[key])) {\n        sourceFormat = SOURCE_FORMAT_KEYED_COLUMNS;\n        break;\n      }\n    }\n  } else if (data != null) {\n    throw new Error('Invalid data');\n  }\n\n  inner(datasetModel).sourceFormat = sourceFormat;\n}\n/**\n * [Scenarios]:\n * (1) Provide source data directly:\n *     series: {\n *         encode: {...},\n *         dimensions: [...]\n *         seriesLayoutBy: 'row',\n *         data: [[...]]\n *     }\n * (2) Refer to datasetModel.\n *     series: [{\n *         encode: {...}\n *         // Ignore datasetIndex means `datasetIndex: 0`\n *         // and the dimensions defination in dataset is used\n *     }, {\n *         encode: {...},\n *         seriesLayoutBy: 'column',\n *         datasetIndex: 1\n *     }]\n *\n * Get data from series itself or datset.\n * @return {module:echarts/data/Source} source\n */\n\n\nfunction getSource(seriesModel) {\n  return inner(seriesModel).source;\n}\n/**\n * MUST be called before mergeOption of all series.\n * @param {module:echarts/model/Global} ecModel\n */\n\n\nfunction resetSourceDefaulter(ecModel) {\n  // `datasetMap` is used to make default encode.\n  inner(ecModel).datasetMap = createHashMap();\n}\n/**\n * [Caution]:\n * MUST be called after series option merged and\n * before \"series.getInitailData()\" called.\n *\n * [The rule of making default encode]:\n * Category axis (if exists) alway map to the first dimension.\n * Each other axis occupies a subsequent dimension.\n *\n * [Why make default encode]:\n * Simplify the typing of encode in option, avoiding the case like that:\n * series: [{encode: {x: 0, y: 1}}, {encode: {x: 0, y: 2}}, {encode: {x: 0, y: 3}}],\n * where the \"y\" have to be manually typed as \"1, 2, 3, ...\".\n *\n * @param {module:echarts/model/Series} seriesModel\n */\n\n\nfunction prepareSource(seriesModel) {\n  var seriesOption = seriesModel.option;\n  var data = seriesOption.data;\n  var sourceFormat = isTypedArray(data) ? SOURCE_FORMAT_TYPED_ARRAY : SOURCE_FORMAT_ORIGINAL;\n  var fromDataset = false;\n  var seriesLayoutBy = seriesOption.seriesLayoutBy;\n  var sourceHeader = seriesOption.sourceHeader;\n  var dimensionsDefine = seriesOption.dimensions;\n  var datasetModel = getDatasetModel(seriesModel);\n\n  if (datasetModel) {\n    var datasetOption = datasetModel.option;\n    data = datasetOption.source;\n    sourceFormat = inner(datasetModel).sourceFormat;\n    fromDataset = true; // These settings from series has higher priority.\n\n    seriesLayoutBy = seriesLayoutBy || datasetOption.seriesLayoutBy;\n    sourceHeader == null && (sourceHeader = datasetOption.sourceHeader);\n    dimensionsDefine = dimensionsDefine || datasetOption.dimensions;\n  }\n\n  var completeResult = completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine); // Note: dataset option does not have `encode`.\n\n  var encodeDefine = seriesOption.encode;\n\n  if (!encodeDefine && datasetModel) {\n    encodeDefine = makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult);\n  }\n\n  inner(seriesModel).source = new Source({\n    data: data,\n    fromDataset: fromDataset,\n    seriesLayoutBy: seriesLayoutBy,\n    sourceFormat: sourceFormat,\n    dimensionsDefine: completeResult.dimensionsDefine,\n    startIndex: completeResult.startIndex,\n    dimensionsDetectCount: completeResult.dimensionsDetectCount,\n    encodeDefine: encodeDefine\n  });\n} // return {startIndex, dimensionsDefine, dimensionsCount}\n\n\nfunction completeBySourceData(data, sourceFormat, seriesLayoutBy, sourceHeader, dimensionsDefine) {\n  if (!data) {\n    return {\n      dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine)\n    };\n  }\n\n  var dimensionsDetectCount;\n  var startIndex;\n  var findPotentialName;\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    // Rule: Most of the first line are string: it is header.\n    // Caution: consider a line with 5 string and 1 number,\n    // it still can not be sure it is a head, because the\n    // 5 string may be 5 values of category columns.\n    if (sourceHeader === 'auto' || sourceHeader == null) {\n      arrayRowsTravelFirst(function (val) {\n        // '-' is regarded as null/undefined.\n        if (val != null && val !== '-') {\n          if (isString(val)) {\n            startIndex == null && (startIndex = 1);\n          } else {\n            startIndex = 0;\n          }\n        } // 10 is an experience number, avoid long loop.\n\n      }, seriesLayoutBy, data, 10);\n    } else {\n      startIndex = sourceHeader ? 1 : 0;\n    }\n\n    if (!dimensionsDefine && startIndex === 1) {\n      dimensionsDefine = [];\n      arrayRowsTravelFirst(function (val, index) {\n        dimensionsDefine[index] = val != null ? val : '';\n      }, seriesLayoutBy, data);\n    }\n\n    dimensionsDetectCount = dimensionsDefine ? dimensionsDefine.length : seriesLayoutBy === SERIES_LAYOUT_BY_ROW ? data.length : data[0] ? data[0].length : null;\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = objectRowsCollectDimensions(data);\n      findPotentialName = true;\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimensionsDefine) {\n      dimensionsDefine = [];\n      findPotentialName = true;\n      each(data, function (colArr, key) {\n        dimensionsDefine.push(key);\n      });\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    var value0 = getDataItemValue(data[0]);\n    dimensionsDetectCount = isArray(value0) && value0.length || 1;\n  } else if (sourceFormat === SOURCE_FORMAT_TYPED_ARRAY) {}\n\n  var potentialNameDimIndex;\n\n  if (findPotentialName) {\n    each(dimensionsDefine, function (dim, idx) {\n      if ((isObject(dim) ? dim.name : dim) === 'name') {\n        potentialNameDimIndex = idx;\n      }\n    });\n  }\n\n  return {\n    startIndex: startIndex,\n    dimensionsDefine: normalizeDimensionsDefine(dimensionsDefine),\n    dimensionsDetectCount: dimensionsDetectCount,\n    potentialNameDimIndex: potentialNameDimIndex // TODO: potentialIdDimIdx\n\n  };\n} // Consider dimensions defined like ['A', 'price', 'B', 'price', 'C', 'price'],\n// which is reasonable. But dimension name is duplicated.\n// Returns undefined or an array contains only object without null/undefiend or string.\n\n\nfunction normalizeDimensionsDefine(dimensionsDefine) {\n  if (!dimensionsDefine) {\n    // The meaning of null/undefined is different from empty array.\n    return;\n  }\n\n  var nameMap = createHashMap();\n  return map(dimensionsDefine, function (item, index) {\n    item = extend({}, isObject(item) ? item : {\n      name: item\n    }); // User can set null in dimensions.\n    // We dont auto specify name, othewise a given name may\n    // cause it be refered unexpectedly.\n\n    if (item.name == null) {\n      return item;\n    } // Also consider number form like 2012.\n\n\n    item.name += ''; // User may also specify displayName.\n    // displayName will always exists except user not\n    // specified or dim name is not specified or detected.\n    // (A auto generated dim name will not be used as\n    // displayName).\n\n    if (item.displayName == null) {\n      item.displayName = item.name;\n    }\n\n    var exist = nameMap.get(item.name);\n\n    if (!exist) {\n      nameMap.set(item.name, {\n        count: 1\n      });\n    } else {\n      item.name += '-' + exist.count++;\n    }\n\n    return item;\n  });\n}\n\nfunction arrayRowsTravelFirst(cb, seriesLayoutBy, data, maxLoop) {\n  maxLoop == null && (maxLoop = Infinity);\n\n  if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      cb(data[i] ? data[i][0] : null, i);\n    }\n  } else {\n    var value0 = data[0] || [];\n\n    for (var i = 0; i < value0.length && i < maxLoop; i++) {\n      cb(value0[i], i);\n    }\n  }\n}\n\nfunction objectRowsCollectDimensions(data) {\n  var firstIndex = 0;\n  var obj;\n\n  while (firstIndex < data.length && !(obj = data[firstIndex++])) {} // jshint ignore: line\n\n\n  if (obj) {\n    var dimensions = [];\n    each(obj, function (value, key) {\n      dimensions.push(key);\n    });\n    return dimensions;\n  }\n} // ??? TODO merge to completedimensions, where also has\n// default encode making logic. And the default rule\n// should depends on series? consider 'map'.\n\n\nfunction makeDefaultEncode(seriesModel, datasetModel, data, sourceFormat, seriesLayoutBy, completeResult) {\n  var coordSysDefine = getCoordSysDefineBySeries(seriesModel);\n  var encode = {}; // var encodeTooltip = [];\n  // var encodeLabel = [];\n\n  var encodeItemName = [];\n  var encodeSeriesName = [];\n  var seriesType = seriesModel.subType; // ??? TODO refactor: provide by series itself.\n  // Consider the case: 'map' series is based on geo coordSys,\n  // 'graph', 'heatmap' can be based on cartesian. But can not\n  // give default rule simply here.\n\n  var nSeriesMap = createHashMap(['pie', 'map', 'funnel']);\n  var cSeriesMap = createHashMap(['line', 'bar', 'pictorialBar', 'scatter', 'effectScatter', 'candlestick', 'boxplot']); // Usually in this case series will use the first data\n  // dimension as the \"value\" dimension, or other default\n  // processes respectively.\n\n  if (coordSysDefine && cSeriesMap.get(seriesType) != null) {\n    var ecModel = seriesModel.ecModel;\n    var datasetMap = inner(ecModel).datasetMap;\n    var key = datasetModel.uid + '_' + seriesLayoutBy;\n    var datasetRecord = datasetMap.get(key) || datasetMap.set(key, {\n      categoryWayDim: 1,\n      valueWayDim: 0\n    }); // TODO\n    // Auto detect first time axis and do arrangement.\n\n    each(coordSysDefine.coordSysDims, function (coordDim) {\n      // In value way.\n      if (coordSysDefine.firstCategoryDimIndex == null) {\n        var dataDim = datasetRecord.valueWayDim++;\n        encode[coordDim] = dataDim; // ??? TODO give a better default series name rule?\n        // especially when encode x y specified.\n        // consider: when mutiple series share one dimension\n        // category axis, series name should better use\n        // the other dimsion name. On the other hand, use\n        // both dimensions name.\n\n        encodeSeriesName.push(dataDim); // encodeTooltip.push(dataDim);\n        // encodeLabel.push(dataDim);\n      } // In category way, category axis.\n      else if (coordSysDefine.categoryAxisMap.get(coordDim)) {\n          encode[coordDim] = 0;\n          encodeItemName.push(0);\n        } // In category way, non-category axis.\n        else {\n            var dataDim = datasetRecord.categoryWayDim++;\n            encode[coordDim] = dataDim; // encodeTooltip.push(dataDim);\n            // encodeLabel.push(dataDim);\n\n            encodeSeriesName.push(dataDim);\n          }\n    });\n  } // Do not make a complex rule! Hard to code maintain and not necessary.\n  // ??? TODO refactor: provide by series itself.\n  // [{name: ..., value: ...}, ...] like:\n  else if (nSeriesMap.get(seriesType) != null) {\n      // Find the first not ordinal. (5 is an experience value)\n      var firstNotOrdinal;\n\n      for (var i = 0; i < 5 && firstNotOrdinal == null; i++) {\n        if (!doGuessOrdinal(data, sourceFormat, seriesLayoutBy, completeResult.dimensionsDefine, completeResult.startIndex, i)) {\n          firstNotOrdinal = i;\n        }\n      }\n\n      if (firstNotOrdinal != null) {\n        encode.value = firstNotOrdinal;\n        var nameDimIndex = completeResult.potentialNameDimIndex || Math.max(firstNotOrdinal - 1, 0); // By default, label use itemName in charts.\n        // So we dont set encodeLabel here.\n\n        encodeSeriesName.push(nameDimIndex);\n        encodeItemName.push(nameDimIndex); // encodeTooltip.push(firstNotOrdinal);\n      }\n    } // encodeTooltip.length && (encode.tooltip = encodeTooltip);\n  // encodeLabel.length && (encode.label = encodeLabel);\n\n\n  encodeItemName.length && (encode.itemName = encodeItemName);\n  encodeSeriesName.length && (encode.seriesName = encodeSeriesName);\n  return encode;\n}\n/**\n * If return null/undefined, indicate that should not use datasetModel.\n */\n\n\nfunction getDatasetModel(seriesModel) {\n  var option = seriesModel.option; // Caution: consider the scenario:\n  // A dataset is declared and a series is not expected to use the dataset,\n  // and at the beginning `setOption({series: { noData })` (just prepare other\n  // option but no data), then `setOption({series: {data: [...]}); In this case,\n  // the user should set an empty array to avoid that dataset is used by default.\n\n  var thisData = option.data;\n\n  if (!thisData) {\n    return seriesModel.ecModel.getComponent('dataset', option.datasetIndex || 0);\n  }\n}\n/**\n * The rule should not be complex, otherwise user might not\n * be able to known where the data is wrong.\n * The code is ugly, but how to make it neat?\n *\n * @param {module:echars/data/Source} source\n * @param {number} dimIndex\n * @return {boolean} Whether ordinal.\n */\n\n\nfunction guessOrdinal(source, dimIndex) {\n  return doGuessOrdinal(source.data, source.sourceFormat, source.seriesLayoutBy, source.dimensionsDefine, source.startIndex, dimIndex);\n} // dimIndex may be overflow source data.\n\n\nfunction doGuessOrdinal(data, sourceFormat, seriesLayoutBy, dimensionsDefine, startIndex, dimIndex) {\n  var result; // Experience value.\n\n  var maxLoop = 5;\n\n  if (isTypedArray(data)) {\n    return false;\n  } // When sourceType is 'objectRows' or 'keyedColumns', dimensionsDefine\n  // always exists in source.\n\n\n  var dimName;\n\n  if (dimensionsDefine) {\n    dimName = dimensionsDefine[dimIndex];\n    dimName = isObject(dimName) ? dimName.name : dimName;\n  }\n\n  if (sourceFormat === SOURCE_FORMAT_ARRAY_ROWS) {\n    if (seriesLayoutBy === SERIES_LAYOUT_BY_ROW) {\n      var sample = data[dimIndex];\n\n      for (var i = 0; i < (sample || []).length && i < maxLoop; i++) {\n        if ((result = detectValue(sample[startIndex + i])) != null) {\n          return result;\n        }\n      }\n    } else {\n      for (var i = 0; i < data.length && i < maxLoop; i++) {\n        var row = data[startIndex + i];\n\n        if (row && (result = detectValue(row[dimIndex])) != null) {\n          return result;\n        }\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_OBJECT_ROWS) {\n    if (!dimName) {\n      return;\n    }\n\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n\n      if (item && (result = detectValue(item[dimName])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_KEYED_COLUMNS) {\n    if (!dimName) {\n      return;\n    }\n\n    var sample = data[dimName];\n\n    if (!sample || isTypedArray(sample)) {\n      return false;\n    }\n\n    for (var i = 0; i < sample.length && i < maxLoop; i++) {\n      if ((result = detectValue(sample[i])) != null) {\n        return result;\n      }\n    }\n  } else if (sourceFormat === SOURCE_FORMAT_ORIGINAL) {\n    for (var i = 0; i < data.length && i < maxLoop; i++) {\n      var item = data[i];\n      var val = getDataItemValue(item);\n\n      if (!isArray(val)) {\n        return false;\n      }\n\n      if ((result = detectValue(val[dimIndex])) != null) {\n        return result;\n      }\n    }\n  }\n\n  function detectValue(val) {\n    // Consider usage convenience, '1', '2' will be treated as \"number\".\n    // `isFinit('')` get `true`.\n    if (val != null && isFinite(val) && val !== '') {\n      return false;\n    } else if (isString(val) && val !== '-') {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexports.detectSourceFormat = detectSourceFormat;\nexports.getSource = getSource;\nexports.resetSourceDefaulter = resetSourceDefaulter;\nexports.prepareSource = prepareSource;\nexports.guessOrdinal = guessOrdinal;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}