{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\nvar __DEV__ = _config.__DEV__;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar Model = require(\"../model/Model\");\nvar DataDiffer = require(\"./DataDiffer\");\nvar Source = require(\"./Source\");\nvar _dataProvider = require(\"./helper/dataProvider\");\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n *      Spetial fields: {\n *          ordinalMeta: <module:echarts/data/OrdinalMeta>\n *          createInvertedIndices: <boolean>\n *      }\n * @param {module:echarts/model/Model} hostModel\n */\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        defualt label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n  if (!rawData.persistent) {\n    end += start;\n  }\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n  var emptyDataItem = new Array(dimLen);\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n    var dimInfo = dimensionInfoMap[dim];\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n  var dataItem = new Array(dimLen);\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n      var id = dataItem == null ? null : dataItem.id;\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n        nameRepeatCount[name]++;\n      }\n      id != null && (idList[idx] = id);\n    }\n  }\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n  return val;\n}\n/**\n * @return {number}\n */\n\nlistProto.count = function () {\n  return this._count;\n};\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\nlistProto.get = function (dim, idx\n/*, stack */) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n  var storage = this._storage;\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n  var dimStore = this._storage[dim];\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */) {\n  var values = [];\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\nlistProto.getDataExtent = function (dim\n/*, stack */) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n  dimExtent = this._extent[dim];\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */);\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\nlistProto.getSum = function (dim\n/*, stack */) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */);\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\nlistProto.getMedian = function (dim\n/*, stack */) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n  var left = 0;\n  var right = this._count - 1;\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n  if (!dimData) {\n    return nearestIndices;\n  }\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i\n    /*, stack */);\n\n    var dist = Math.abs(diff);\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n      nearestIndices.push(i);\n    }\n  }\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n  return id;\n}\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n  return dimensions;\n}\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n      default:\n        var k = 0;\n        var value = [];\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n  var dimensions = [];\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n  var dimSize = dimensions.length;\n  if (!dimSize) {\n    return;\n  }\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n      }\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n          idx++;\n        }\n      }\n      quickFinished = true;\n    }\n  }\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n  return list;\n}\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n  return newDimStore;\n}\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  // contextCompat just for compat echarts3\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */);\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n    newIndices[offset++] = sampleFrameIdx;\n  }\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n    return;\n  }\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n    return;\n  }\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n    return;\n  }\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n  this.__wrappedMethods = this.__wrappedMethods || [];\n  this.__wrappedMethods.push(methodName);\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","Model","DataDiffer","Source","_dataProvider","defaultDimValueGetters","DefaultDataProvider","_dimensionHelper","summarizeDimensions","isObject","UNDEFINED","INDEX_NOT_FOUND","ID_PREFIX","dataCtors","Float64Array","Array","Int32Array","CtorUint32Array","Uint32Array","CtorInt32Array","CtorUint16Array","Uint16Array","getIndicesCtor","list","_rawCount","cloneChunk","originalChunk","Ctor","constructor","slice","TRANSFERABLE_PROPERTIES","CLONE_PROPERTIES","transferProperties","target","source","each","concat","__wrappedMethods","propName","hasOwnProperty","clone","_calculationInfo","extend","List","dimensions","hostModel","dimensionInfos","dimensionNames","invertedIndicesMap","i","length","dimensionInfo","isString","name","dimensionName","type","coordDim","coordDimIndex","otherDims","push","index","createInvertedIndices","_dimensionInfos","dataType","_indices","_count","_storage","_nameList","_idList","_optionModels","_visual","_layout","_itemVisuals","hasItemVisual","_itemLayouts","_graphicEls","_chunkSize","_chunkCount","_rawData","_rawExtent","_extent","_approximateExtent","_dimensionsSummary","_invertedIndicesMap","userOutput","listProto","prototype","hasItemOption","getDimension","dim","isNaN","getDimensionInfo","getDimensionsOnCoord","dataDimsOnCoord","mapDimension","idx","dimensionsSummary","encodeFirstDimNotExtra","dims","encode","initData","data","nameList","dimValueGetter","notProvider","isInstance","isArrayLike","_nameRepeatCount","defaultDimValueGetter","getSource","sourceFormat","_dimValueGetter","_dimValueGetterArrayRows","arrayRows","_initDataFromProvider","count","pure","getProvider","appendData","rawData","start","end","persistent","appendValues","values","names","chunkSize","storage","dimLen","rawExtent","Math","max","originalChunkCount","getInitialExtent","prepareChunks","emptyDataItem","sourceIdx","chunkIndex","floor","chunkOffset","k","val","dimRawExtent","prepareInvertedIndex","dimensionInfoMap","idList","nameRepeatCount","nameDimIdx","dimInfo","itemName","_nameDimIdx","itemId","_idDimIdx","dataItem","getItem","dimStorage","nameDim","nameDimChunk","ordinalMeta","categories","id","clean","chunkCount","DataCtor","lastChunkIndex","resizeChunkArray","newStore","min","j","invertedIndices","get","getRawValueFromStore","dimIndex","rawIndex","chunk","getIndices","newIndices","indices","thisCount","buffer","NaN","getRawIndex","chunkStore","value","getByRawIndex","rawIdx","dimStore","_getFast","getValues","isArray","len","hasValue","getDataExtent","dimData","initialExtent","currEnd","useRaw","dimExtent","getApproximateExtent","setApproximateExtent","extent","getCalculationInfo","key","setCalculationInfo","getSum","sum","getMedian","dimDataArray","sortedDimDataArray","sort","a","b","rawIndexOf","indexOfName","getName","indexOfRawIndex","rawDataIndex","left","right","mid","indicesOfNearest","maxDistance","nearestIndices","Infinity","minDist","Number","MAX_VALUE","minDiff","diff","dist","abs","getRawIndexWithoutIndices","getRawIndexWithIndices","getRawDataItem","getId","normalizeDimensions","validateDimensions","console","error","cb","context","contextCompat","map","dimSize","call","apply","filterSelf","offset","dim0","keep","selectRange","range","originalCount","quickFinished","chunkStorage","dimStorage2","min2","max2","chunkStorage2","val2","dimk","mapArray","result","arguments","cloneListForMapAndSample","original","excludeDimensions","allDimensions","originalStorage","indexOf","cloneDimStore","originalDimStore","newDimStore","tmpRetValue","dataCount","dataIndex","retValue","rawExtentOnDim","downSample","dimension","rate","sampleValue","sampleIndex","targetStorage","frameValues","frameSize","dataIdx","originalChunkIndex","originalChunkOffset","sampleFrameIdx","sampleChunkIndex","sampleChunkOffset","getItemModel","ecModel","otherList","thisList","getVisual","visual","setVisual","setLayout","getLayout","getItemLayout","setItemLayout","layout","merge","clearItemLayouts","getItemVisual","ignoreParent","itemVisual","setItemVisual","clearAllVisual","setItemDataAndSeriesIndex","child","seriesIndex","setItemGraphicEl","el","traverse","getItemGraphicEl","eachItemGraphicEl","cloneShallow","dimensionInfoList","wrapMethod","methodName","injectFunction","originalMethod","res","TRANSFERABLE_METHODS","CHANGABLE_METHODS","_default","module","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/data/List.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Model = require(\"../model/Model\");\n\nvar DataDiffer = require(\"./DataDiffer\");\n\nvar Source = require(\"./Source\");\n\nvar _dataProvider = require(\"./helper/dataProvider\");\n\nvar defaultDimValueGetters = _dataProvider.defaultDimValueGetters;\nvar DefaultDataProvider = _dataProvider.DefaultDataProvider;\n\nvar _dimensionHelper = require(\"./helper/dimensionHelper\");\n\nvar summarizeDimensions = _dimensionHelper.summarizeDimensions;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\n/* global Float64Array, Int32Array, Uint32Array, Uint16Array */\n\n/**\n * List for data storage\n * @module echarts/data/List\n */\nvar isObject = zrUtil.isObject;\nvar UNDEFINED = 'undefined';\nvar INDEX_NOT_FOUND = -1; // Use prefix to avoid index to be the same as otherIdList[idx],\n// which will cause weird udpate animation.\n\nvar ID_PREFIX = 'e\\0\\0';\nvar dataCtors = {\n  'float': typeof Float64Array === UNDEFINED ? Array : Float64Array,\n  'int': typeof Int32Array === UNDEFINED ? Array : Int32Array,\n  // Ordinal data type can be string or int\n  'ordinal': Array,\n  'number': Array,\n  'time': Array\n}; // Caution: MUST not use `new CtorUint32Array(arr, 0, len)`, because the Ctor of array is\n// different from the Ctor of typed array.\n\nvar CtorUint32Array = typeof Uint32Array === UNDEFINED ? Array : Uint32Array;\nvar CtorInt32Array = typeof Int32Array === UNDEFINED ? Array : Int32Array;\nvar CtorUint16Array = typeof Uint16Array === UNDEFINED ? Array : Uint16Array;\n\nfunction getIndicesCtor(list) {\n  // The possible max value in this._indicies is always this._rawCount despite of filtering.\n  return list._rawCount > 65535 ? CtorUint32Array : CtorUint16Array;\n}\n\nfunction cloneChunk(originalChunk) {\n  var Ctor = originalChunk.constructor; // Only shallow clone is enough when Array.\n\n  return Ctor === Array ? originalChunk.slice() : new Ctor(originalChunk);\n}\n\nvar TRANSFERABLE_PROPERTIES = ['hasItemOption', '_nameList', '_idList', '_invertedIndicesMap', '_rawData', '_chunkSize', '_chunkCount', '_dimValueGetter', '_count', '_rawCount', '_nameDimIdx', '_idDimIdx'];\nvar CLONE_PROPERTIES = ['_extent', '_approximateExtent', '_rawExtent'];\n\nfunction transferProperties(target, source) {\n  zrUtil.each(TRANSFERABLE_PROPERTIES.concat(source.__wrappedMethods || []), function (propName) {\n    if (source.hasOwnProperty(propName)) {\n      target[propName] = source[propName];\n    }\n  });\n  target.__wrappedMethods = source.__wrappedMethods;\n  zrUtil.each(CLONE_PROPERTIES, function (propName) {\n    target[propName] = zrUtil.clone(source[propName]);\n  });\n  target._calculationInfo = zrUtil.extend(source._calculationInfo);\n}\n/**\n * @constructor\n * @alias module:echarts/data/List\n *\n * @param {Array.<string|Object>} dimensions\n *      For example, ['someDimName', {name: 'someDimName', type: 'someDimType'}, ...].\n *      Dimensions should be concrete names like x, y, z, lng, lat, angle, radius\n *      Spetial fields: {\n *          ordinalMeta: <module:echarts/data/OrdinalMeta>\n *          createInvertedIndices: <boolean>\n *      }\n * @param {module:echarts/model/Model} hostModel\n */\n\n\nvar List = function (dimensions, hostModel) {\n  dimensions = dimensions || ['x', 'y'];\n  var dimensionInfos = {};\n  var dimensionNames = [];\n  var invertedIndicesMap = {};\n\n  for (var i = 0; i < dimensions.length; i++) {\n    // Use the original dimensions[i], where other flag props may exists.\n    var dimensionInfo = dimensions[i];\n\n    if (zrUtil.isString(dimensionInfo)) {\n      dimensionInfo = {\n        name: dimensionInfo\n      };\n    }\n\n    var dimensionName = dimensionInfo.name;\n    dimensionInfo.type = dimensionInfo.type || 'float';\n\n    if (!dimensionInfo.coordDim) {\n      dimensionInfo.coordDim = dimensionName;\n      dimensionInfo.coordDimIndex = 0;\n    }\n\n    dimensionInfo.otherDims = dimensionInfo.otherDims || {};\n    dimensionNames.push(dimensionName);\n    dimensionInfos[dimensionName] = dimensionInfo;\n    dimensionInfo.index = i;\n\n    if (dimensionInfo.createInvertedIndices) {\n      invertedIndicesMap[dimensionName] = [];\n    }\n  }\n  /**\n   * @readOnly\n   * @type {Array.<string>}\n   */\n\n\n  this.dimensions = dimensionNames;\n  /**\n   * Infomation of each data dimension, like data type.\n   * @type {Object}\n   */\n\n  this._dimensionInfos = dimensionInfos;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.hostModel = hostModel;\n  /**\n   * @type {module:echarts/model/Model}\n   */\n\n  this.dataType;\n  /**\n   * Indices stores the indices of data subset after filtered.\n   * This data subset will be used in chart.\n   * @type {Array.<number>}\n   * @readOnly\n   */\n\n  this._indices = null;\n  this._count = 0;\n  this._rawCount = 0;\n  /**\n   * Data storage\n   * @type {Object.<key, Array.<TypedArray|Array>>}\n   * @private\n   */\n\n  this._storage = {};\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._nameList = [];\n  /**\n   * @type {Array.<string>}\n   */\n\n  this._idList = [];\n  /**\n   * Models of data option is stored sparse for optimizing memory cost\n   * @type {Array.<module:echarts/model/Model>}\n   * @private\n   */\n\n  this._optionModels = [];\n  /**\n   * Global visual properties after visual coding\n   * @type {Object}\n   * @private\n   */\n\n  this._visual = {};\n  /**\n   * Globel layout properties.\n   * @type {Object}\n   * @private\n   */\n\n  this._layout = {};\n  /**\n   * Item visual properties after visual coding\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemVisuals = [];\n  /**\n   * Key: visual type, Value: boolean\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.hasItemVisual = {};\n  /**\n   * Item layout properties after layout\n   * @type {Array.<Object>}\n   * @private\n   */\n\n  this._itemLayouts = [];\n  /**\n   * Graphic elemnents\n   * @type {Array.<module:zrender/Element>}\n   * @private\n   */\n\n  this._graphicEls = [];\n  /**\n   * Max size of each chunk.\n   * @type {number}\n   * @private\n   */\n\n  this._chunkSize = 1e5;\n  /**\n   * @type {number}\n   * @private\n   */\n\n  this._chunkCount = 0;\n  /**\n   * @type {Array.<Array|Object>}\n   * @private\n   */\n\n  this._rawData;\n  /**\n   * Raw extent will not be cloned, but only transfered.\n   * It will not be calculated util needed.\n   * key: dim,\n   * value: {end: number, extent: Array.<number>}\n   * @type {Object}\n   * @private\n   */\n\n  this._rawExtent = {};\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._extent = {};\n  /**\n   * key: dim\n   * value: extent\n   * @type {Object}\n   * @private\n   */\n\n  this._approximateExtent = {};\n  /**\n   * Cache summary info for fast visit. See \"dimensionHelper\".\n   * @type {Object}\n   * @private\n   */\n\n  this._dimensionsSummary = summarizeDimensions(this);\n  /**\n   * @type {Object.<Array|TypedArray>}\n   * @private\n   */\n\n  this._invertedIndicesMap = invertedIndicesMap;\n  /**\n   * @type {Object}\n   * @private\n   */\n\n  this._calculationInfo = {};\n  /**\n   * User output info of this data.\n   * DO NOT use it in other places!\n   *\n   * When preparing user params for user callbacks, we have\n   * to clone these inner data structures to prevent users\n   * from modifying them to effect built-in logic. And for\n   * performance consideration we make this `userOutput` to\n   * avoid clone them too many times.\n   *\n   * @type {Object}\n   * @readOnly\n   */\n\n  this.userOutput = this._dimensionsSummary.userOutput;\n};\n\nvar listProto = List.prototype;\nlistProto.type = 'list';\n/**\n * If each data item has it's own option\n * @type {boolean}\n */\n\nlistProto.hasItemOption = true;\n/**\n * The meanings of the input parameter `dim`:\n *\n * + If dim is a number (e.g., `1`), it means the index of the dimension.\n *   For example, `getDimension(0)` will return 'x' or 'lng' or 'radius'.\n * + If dim is a number-like string (e.g., `\"1\"`):\n *     + If there is the same concrete dim name defined in `this.dimensions`, it means that concrete name.\n *     + If not, it will be converted to a number, which means the index of the dimension.\n *        (why? because of the backward compatbility. We have been tolerating number-like string in\n *        dimension setting, although now it seems that it is not a good idea.)\n *     For example, `visualMap[i].dimension: \"1\"` is the same meaning as `visualMap[i].dimension: 1`,\n *     if no dimension name is defined as `\"1\"`.\n * + If dim is a not-number-like string, it means the concrete dim name.\n *   For example, it can be be default name `\"x\"`, `\"y\"`, `\"z\"`, `\"lng\"`, `\"lat\"`, `\"angle\"`, `\"radius\"`,\n *   or customized in `dimensions` property of option like `\"age\"`.\n *\n * Get dimension name\n * @param {string|number} dim See above.\n * @return {string} Concrete dim name.\n */\n\nlistProto.getDimension = function (dim) {\n  if (typeof dim === 'number' // If being a number-like string but not being defined a dimension name.\n  || !isNaN(dim) && !this._dimensionInfos.hasOwnProperty(dim)) {\n    dim = this.dimensions[dim];\n  }\n\n  return dim;\n};\n/**\n * Get type and calculation info of particular dimension\n * @param {string|number} dim\n *        Dimension can be concrete names like x, y, z, lng, lat, angle, radius\n *        Or a ordinal number. For example getDimensionInfo(0) will return 'x' or 'lng' or 'radius'\n */\n\n\nlistProto.getDimensionInfo = function (dim) {\n  // Do not clone, because there may be categories in dimInfo.\n  return this._dimensionInfos[this.getDimension(dim)];\n};\n/**\n * @return {Array.<string>} concrete dimension name list on coord.\n */\n\n\nlistProto.getDimensionsOnCoord = function () {\n  return this._dimensionsSummary.dataDimsOnCoord.slice();\n};\n/**\n * @param {string} coordDim\n * @param {number} [idx] A coordDim may map to more than one data dim.\n *        If idx is `true`, return a array of all mapped dims.\n *        If idx is not specified, return the first dim not extra.\n * @return {string|Array.<string>} concrete data dim.\n *        If idx is number, and not found, return null/undefined.\n *        If idx is `true`, and not found, return empty array (always return array).\n */\n\n\nlistProto.mapDimension = function (coordDim, idx) {\n  var dimensionsSummary = this._dimensionsSummary;\n\n  if (idx == null) {\n    return dimensionsSummary.encodeFirstDimNotExtra[coordDim];\n  }\n\n  var dims = dimensionsSummary.encode[coordDim];\n  return idx === true // always return array if idx is `true`\n  ? (dims || []).slice() : dims && dims[idx];\n};\n/**\n * Initialize from data\n * @param {Array.<Object|number|Array>} data source or data or data provider.\n * @param {Array.<string>} [nameLIst] The name of a datum is used on data diff and\n *        defualt label/tooltip.\n *        A name can be specified in encode.itemName,\n *        or dataItem.name (only for series option data),\n *        or provided in nameList from outside.\n * @param {Function} [dimValueGetter] (dataItem, dimName, dataIndex, dimIndex) => number\n */\n\n\nlistProto.initData = function (data, nameList, dimValueGetter) {\n  var notProvider = Source.isInstance(data) || zrUtil.isArrayLike(data);\n\n  if (notProvider) {\n    data = new DefaultDataProvider(data, this.dimensions.length);\n  }\n\n  this._rawData = data; // Clear\n\n  this._storage = {};\n  this._indices = null;\n  this._nameList = nameList || [];\n  this._idList = [];\n  this._nameRepeatCount = {};\n\n  if (!dimValueGetter) {\n    this.hasItemOption = false;\n  }\n  /**\n   * @readOnly\n   */\n\n\n  this.defaultDimValueGetter = defaultDimValueGetters[this._rawData.getSource().sourceFormat]; // Default dim value getter\n\n  this._dimValueGetter = dimValueGetter = dimValueGetter || this.defaultDimValueGetter;\n  this._dimValueGetterArrayRows = defaultDimValueGetters.arrayRows; // Reset raw extent.\n\n  this._rawExtent = {};\n\n  this._initDataFromProvider(0, data.count()); // If data has no item option.\n\n\n  if (data.pure) {\n    this.hasItemOption = false;\n  }\n};\n\nlistProto.getProvider = function () {\n  return this._rawData;\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n */\n\n\nlistProto.appendData = function (data) {\n  var rawData = this._rawData;\n  var start = this.count();\n  rawData.appendData(data);\n  var end = rawData.count();\n\n  if (!rawData.persistent) {\n    end += start;\n  }\n\n  this._initDataFromProvider(start, end);\n};\n/**\n * Caution: Can be only called on raw data (before `this._indices` created).\n * This method does not modify `rawData` (`dataProvider`), but only\n * add values to storage.\n *\n * The final count will be increased by `Math.max(values.length, names.length)`.\n *\n * @param {Array.<Array.<*>>} values That is the SourceType: 'arrayRows', like\n *        [\n *            [12, 33, 44],\n *            [NaN, 43, 1],\n *            ['-', 'asdf', 0]\n *        ]\n *        Each item is exaclty cooresponding to a dimension.\n * @param {Array.<string>} [names]\n */\n\n\nlistProto.appendValues = function (values, names) {\n  var chunkSize = this._chunkSize;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var rawExtent = this._rawExtent;\n  var start = this.count();\n  var end = start + Math.max(values.length, names ? names.length : 0);\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, this._dimensionInfos[dim], chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var emptyDataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    var sourceIdx = idx - start;\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n\n      var val = this._dimValueGetterArrayRows(values[sourceIdx] || emptyDataItem, dim, sourceIdx, k);\n\n      storage[dim][chunkIndex][chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    }\n\n    if (names) {\n      this._nameList[idx] = names[sourceIdx];\n    }\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nlistProto._initDataFromProvider = function (start, end) {\n  // Optimize.\n  if (start >= end) {\n    return;\n  }\n\n  var chunkSize = this._chunkSize;\n  var rawData = this._rawData;\n  var storage = this._storage;\n  var dimensions = this.dimensions;\n  var dimLen = dimensions.length;\n  var dimensionInfoMap = this._dimensionInfos;\n  var nameList = this._nameList;\n  var idList = this._idList;\n  var rawExtent = this._rawExtent;\n  var nameRepeatCount = this._nameRepeatCount = {};\n  var nameDimIdx;\n  var originalChunkCount = this._chunkCount;\n\n  for (var i = 0; i < dimLen; i++) {\n    var dim = dimensions[i];\n\n    if (!rawExtent[dim]) {\n      rawExtent[dim] = getInitialExtent();\n    }\n\n    var dimInfo = dimensionInfoMap[dim];\n\n    if (dimInfo.otherDims.itemName === 0) {\n      nameDimIdx = this._nameDimIdx = i;\n    }\n\n    if (dimInfo.otherDims.itemId === 0) {\n      this._idDimIdx = i;\n    }\n\n    if (!storage[dim]) {\n      storage[dim] = [];\n    }\n\n    prepareChunks(storage, dimInfo, chunkSize, originalChunkCount, end);\n    this._chunkCount = storage[dim].length;\n  }\n\n  var dataItem = new Array(dimLen);\n\n  for (var idx = start; idx < end; idx++) {\n    // NOTICE: Try not to write things into dataItem\n    dataItem = rawData.getItem(idx, dataItem); // Each data item is value\n    // [1, 2]\n    // 2\n    // Bar chart, line chart which uses category axis\n    // only gives the 'y' value. 'x' value is the indices of category\n    // Use a tempValue to normalize the value to be a (x, y) value\n\n    var chunkIndex = Math.floor(idx / chunkSize);\n    var chunkOffset = idx % chunkSize; // Store the data by dimensions\n\n    for (var k = 0; k < dimLen; k++) {\n      var dim = dimensions[k];\n      var dimStorage = storage[dim][chunkIndex]; // PENDING NULL is empty or zero\n\n      var val = this._dimValueGetter(dataItem, dim, idx, k);\n\n      dimStorage[chunkOffset] = val;\n      var dimRawExtent = rawExtent[dim];\n      val < dimRawExtent[0] && (dimRawExtent[0] = val);\n      val > dimRawExtent[1] && (dimRawExtent[1] = val);\n    } // ??? FIXME not check by pure but sourceFormat?\n    // TODO refactor these logic.\n\n\n    if (!rawData.pure) {\n      var name = nameList[idx];\n\n      if (dataItem && name == null) {\n        // If dataItem is {name: ...}, it has highest priority.\n        // That is appropriate for many common cases.\n        if (dataItem.name != null) {\n          // There is no other place to persistent dataItem.name,\n          // so save it to nameList.\n          nameList[idx] = name = dataItem.name;\n        } else if (nameDimIdx != null) {\n          var nameDim = dimensions[nameDimIdx];\n          var nameDimChunk = storage[nameDim][chunkIndex];\n\n          if (nameDimChunk) {\n            name = nameDimChunk[chunkOffset];\n            var ordinalMeta = dimensionInfoMap[nameDim].ordinalMeta;\n\n            if (ordinalMeta && ordinalMeta.categories.length) {\n              name = ordinalMeta.categories[name];\n            }\n          }\n        }\n      } // Try using the id in option\n      // id or name is used on dynamical data, mapping old and new items.\n\n\n      var id = dataItem == null ? null : dataItem.id;\n\n      if (id == null && name != null) {\n        // Use name as id and add counter to avoid same name\n        nameRepeatCount[name] = nameRepeatCount[name] || 0;\n        id = name;\n\n        if (nameRepeatCount[name] > 0) {\n          id += '__ec__' + nameRepeatCount[name];\n        }\n\n        nameRepeatCount[name]++;\n      }\n\n      id != null && (idList[idx] = id);\n    }\n  }\n\n  if (!rawData.persistent && rawData.clean) {\n    // Clean unused data if data source is typed array.\n    rawData.clean();\n  }\n\n  this._rawCount = this._count = end; // Reset data extent\n\n  this._extent = {};\n  prepareInvertedIndex(this);\n};\n\nfunction prepareChunks(storage, dimInfo, chunkSize, chunkCount, end) {\n  var DataCtor = dataCtors[dimInfo.type];\n  var lastChunkIndex = chunkCount - 1;\n  var dim = dimInfo.name;\n  var resizeChunkArray = storage[dim][lastChunkIndex];\n\n  if (resizeChunkArray && resizeChunkArray.length < chunkSize) {\n    var newStore = new DataCtor(Math.min(end - lastChunkIndex * chunkSize, chunkSize)); // The cost of the copy is probably inconsiderable\n    // within the initial chunkSize.\n\n    for (var j = 0; j < resizeChunkArray.length; j++) {\n      newStore[j] = resizeChunkArray[j];\n    }\n\n    storage[dim][lastChunkIndex] = newStore;\n  } // Create new chunks.\n\n\n  for (var k = chunkCount * chunkSize; k < end; k += chunkSize) {\n    storage[dim].push(new DataCtor(Math.min(end - k, chunkSize)));\n  }\n}\n\nfunction prepareInvertedIndex(list) {\n  var invertedIndicesMap = list._invertedIndicesMap;\n  zrUtil.each(invertedIndicesMap, function (invertedIndices, dim) {\n    var dimInfo = list._dimensionInfos[dim]; // Currently, only dimensions that has ordinalMeta can create inverted indices.\n\n    var ordinalMeta = dimInfo.ordinalMeta;\n\n    if (ordinalMeta) {\n      invertedIndices = invertedIndicesMap[dim] = new CtorInt32Array(ordinalMeta.categories.length); // The default value of TypedArray is 0. To avoid miss\n      // mapping to 0, we should set it as INDEX_NOT_FOUND.\n\n      for (var i = 0; i < invertedIndices.length; i++) {\n        invertedIndices[i] = INDEX_NOT_FOUND;\n      }\n\n      for (var i = 0; i < list._count; i++) {\n        // Only support the case that all values are distinct.\n        invertedIndices[list.get(dim, i)] = i;\n      }\n    }\n  });\n}\n\nfunction getRawValueFromStore(list, dimIndex, rawIndex) {\n  var val;\n\n  if (dimIndex != null) {\n    var chunkSize = list._chunkSize;\n    var chunkIndex = Math.floor(rawIndex / chunkSize);\n    var chunkOffset = rawIndex % chunkSize;\n    var dim = list.dimensions[dimIndex];\n    var chunk = list._storage[dim][chunkIndex];\n\n    if (chunk) {\n      val = chunk[chunkOffset];\n      var ordinalMeta = list._dimensionInfos[dim].ordinalMeta;\n\n      if (ordinalMeta && ordinalMeta.categories.length) {\n        val = ordinalMeta.categories[val];\n      }\n    }\n  }\n\n  return val;\n}\n/**\n * @return {number}\n */\n\n\nlistProto.count = function () {\n  return this._count;\n};\n\nlistProto.getIndices = function () {\n  var newIndices;\n  var indices = this._indices;\n\n  if (indices) {\n    var Ctor = indices.constructor;\n    var thisCount = this._count; // `new Array(a, b, c)` is different from `new Uint32Array(a, b, c)`.\n\n    if (Ctor === Array) {\n      newIndices = new Ctor(thisCount);\n\n      for (var i = 0; i < thisCount; i++) {\n        newIndices[i] = indices[i];\n      }\n    } else {\n      newIndices = new Ctor(indices.buffer, 0, thisCount);\n    }\n  } else {\n    var Ctor = getIndicesCtor(this);\n    var newIndices = new Ctor(this.count());\n\n    for (var i = 0; i < newIndices.length; i++) {\n      newIndices[i] = i;\n    }\n  }\n\n  return newIndices;\n};\n/**\n * Get value. Return NaN if idx is out of range.\n * @param {string} dim Dim must be concrete name.\n * @param {number} idx\n * @param {boolean} stack\n * @return {number}\n */\n\n\nlistProto.get = function (dim, idx\n/*, stack */\n) {\n  if (!(idx >= 0 && idx < this._count)) {\n    return NaN;\n  }\n\n  var storage = this._storage;\n\n  if (!storage[dim]) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  idx = this.getRawIndex(idx);\n  var chunkIndex = Math.floor(idx / this._chunkSize);\n  var chunkOffset = idx % this._chunkSize;\n  var chunkStore = storage[dim][chunkIndex];\n  var value = chunkStore[chunkOffset]; // FIXME ordinal data type is not stackable\n  // if (stack) {\n  //     var dimensionInfo = this._dimensionInfos[dim];\n  //     if (dimensionInfo && dimensionInfo.stackable) {\n  //         var stackedOn = this.stackedOn;\n  //         while (stackedOn) {\n  //             // Get no stacked data of stacked on\n  //             var stackedValue = stackedOn.get(dim, idx);\n  //             // Considering positive stack, negative stack and empty data\n  //             if ((value >= 0 && stackedValue > 0)  // Positive stack\n  //                 || (value <= 0 && stackedValue < 0) // Negative stack\n  //             ) {\n  //                 value += stackedValue;\n  //             }\n  //             stackedOn = stackedOn.stackedOn;\n  //         }\n  //     }\n  // }\n\n  return value;\n};\n/**\n * @param {string} dim concrete dim\n * @param {number} rawIndex\n * @return {number|string}\n */\n\n\nlistProto.getByRawIndex = function (dim, rawIdx) {\n  if (!(rawIdx >= 0 && rawIdx < this._rawCount)) {\n    return NaN;\n  }\n\n  var dimStore = this._storage[dim];\n\n  if (!dimStore) {\n    // TODO Warn ?\n    return NaN;\n  }\n\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = dimStore[chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * FIXME Use `get` on chrome maybe slow(in filterSelf and selectRange).\n * Hack a much simpler _getFast\n * @private\n */\n\n\nlistProto._getFast = function (dim, rawIdx) {\n  var chunkIndex = Math.floor(rawIdx / this._chunkSize);\n  var chunkOffset = rawIdx % this._chunkSize;\n  var chunkStore = this._storage[dim][chunkIndex];\n  return chunkStore[chunkOffset];\n};\n/**\n * Get value for multi dimensions.\n * @param {Array.<string>} [dimensions] If ignored, using all dimensions.\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getValues = function (dimensions, idx\n/*, stack */\n) {\n  var values = [];\n\n  if (!zrUtil.isArray(dimensions)) {\n    // stack = idx;\n    idx = dimensions;\n    dimensions = this.dimensions;\n  }\n\n  for (var i = 0, len = dimensions.length; i < len; i++) {\n    values.push(this.get(dimensions[i], idx\n    /*, stack */\n    ));\n  }\n\n  return values;\n};\n/**\n * If value is NaN. Inlcuding '-'\n * Only check the coord dimensions.\n * @param {string} dim\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.hasValue = function (idx) {\n  var dataDimsOnCoord = this._dimensionsSummary.dataDimsOnCoord;\n\n  for (var i = 0, len = dataDimsOnCoord.length; i < len; i++) {\n    // Ordinal type originally can be string or number.\n    // But when an ordinal type is used on coord, it can\n    // not be string but only number. So we can also use isNaN.\n    if (isNaN(this.get(dataDimsOnCoord[i], idx))) {\n      return false;\n    }\n  }\n\n  return true;\n};\n/**\n * Get extent of data in one dimension\n * @param {string} dim\n * @param {boolean} stack\n */\n\n\nlistProto.getDataExtent = function (dim\n/*, stack */\n) {\n  // Make sure use concrete dim as cache name.\n  dim = this.getDimension(dim);\n  var dimData = this._storage[dim];\n  var initialExtent = getInitialExtent(); // stack = !!((stack || false) && this.getCalculationInfo(dim));\n\n  if (!dimData) {\n    return initialExtent;\n  } // Make more strict checkings to ensure hitting cache.\n\n\n  var currEnd = this.count(); // var cacheName = [dim, !!stack].join('_');\n  // var cacheName = dim;\n  // Consider the most cases when using data zoom, `getDataExtent`\n  // happened before filtering. We cache raw extent, which is not\n  // necessary to be cleared and recalculated when restore data.\n\n  var useRaw = !this._indices; // && !stack;\n\n  var dimExtent;\n\n  if (useRaw) {\n    return this._rawExtent[dim].slice();\n  }\n\n  dimExtent = this._extent[dim];\n\n  if (dimExtent) {\n    return dimExtent.slice();\n  }\n\n  dimExtent = initialExtent;\n  var min = dimExtent[0];\n  var max = dimExtent[1];\n\n  for (var i = 0; i < currEnd; i++) {\n    // var value = stack ? this.get(dim, i, true) : this._getFast(dim, this.getRawIndex(i));\n    var value = this._getFast(dim, this.getRawIndex(i));\n\n    value < min && (min = value);\n    value > max && (max = value);\n  }\n\n  dimExtent = [min, max];\n  this._extent[dim] = dimExtent;\n  return dimExtent;\n};\n/**\n * Optimize for the scenario that data is filtered by a given extent.\n * Consider that if data amount is more than hundreds of thousand,\n * extent calculation will cost more than 10ms and the cache will\n * be erased because of the filtering.\n */\n\n\nlistProto.getApproximateExtent = function (dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  return this._approximateExtent[dim] || this.getDataExtent(dim\n  /*, stack */\n  );\n};\n\nlistProto.setApproximateExtent = function (extent, dim\n/*, stack */\n) {\n  dim = this.getDimension(dim);\n  this._approximateExtent[dim] = extent.slice();\n};\n/**\n * @param {string} key\n * @return {*}\n */\n\n\nlistProto.getCalculationInfo = function (key) {\n  return this._calculationInfo[key];\n};\n/**\n * @param {string|Object} key or k-v object\n * @param {*} [value]\n */\n\n\nlistProto.setCalculationInfo = function (key, value) {\n  isObject(key) ? zrUtil.extend(this._calculationInfo, key) : this._calculationInfo[key] = value;\n};\n/**\n * Get sum of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getSum = function (dim\n/*, stack */\n) {\n  var dimData = this._storage[dim];\n  var sum = 0;\n\n  if (dimData) {\n    for (var i = 0, len = this.count(); i < len; i++) {\n      var value = this.get(dim, i\n      /*, stack */\n      );\n\n      if (!isNaN(value)) {\n        sum += value;\n      }\n    }\n  }\n\n  return sum;\n};\n/**\n * Get median of data in one dimension\n * @param {string} dim\n */\n\n\nlistProto.getMedian = function (dim\n/*, stack */\n) {\n  var dimDataArray = []; // map all data of one dimension\n\n  this.each(dim, function (val, idx) {\n    if (!isNaN(val)) {\n      dimDataArray.push(val);\n    }\n  }); // TODO\n  // Use quick select?\n  // immutability & sort\n\n  var sortedDimDataArray = [].concat(dimDataArray).sort(function (a, b) {\n    return a - b;\n  });\n  var len = this.count(); // calculate median\n\n  return len === 0 ? 0 : len % 2 === 1 ? sortedDimDataArray[(len - 1) / 2] : (sortedDimDataArray[len / 2] + sortedDimDataArray[len / 2 - 1]) / 2;\n}; // /**\n//  * Retreive the index with given value\n//  * @param {string} dim Concrete dimension.\n//  * @param {number} value\n//  * @return {number}\n//  */\n// Currently incorrect: should return dataIndex but not rawIndex.\n// Do not fix it until this method is to be used somewhere.\n// FIXME Precision of float value\n// listProto.indexOf = function (dim, value) {\n//     var storage = this._storage;\n//     var dimData = storage[dim];\n//     var chunkSize = this._chunkSize;\n//     if (dimData) {\n//         for (var i = 0, len = this.count(); i < len; i++) {\n//             var chunkIndex = Math.floor(i / chunkSize);\n//             var chunkOffset = i % chunkSize;\n//             if (dimData[chunkIndex][chunkOffset] === value) {\n//                 return i;\n//             }\n//         }\n//     }\n//     return -1;\n// };\n\n/**\n * Only support the dimension which inverted index created.\n * Do not support other cases until required.\n * @param {string} concrete dim\n * @param {number|string} value\n * @return {number} rawIndex\n */\n\n\nlistProto.rawIndexOf = function (dim, value) {\n  var invertedIndices = dim && this._invertedIndicesMap[dim];\n  var rawIndex = invertedIndices[value];\n\n  if (rawIndex == null || isNaN(rawIndex)) {\n    return INDEX_NOT_FOUND;\n  }\n\n  return rawIndex;\n};\n/**\n * Retreive the index with given name\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfName = function (name) {\n  for (var i = 0, len = this.count(); i < len; i++) {\n    if (this.getName(i) === name) {\n      return i;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index with given raw data index\n * @param {number} idx\n * @param {number} name\n * @return {number}\n */\n\n\nlistProto.indexOfRawIndex = function (rawIndex) {\n  if (rawIndex >= this._rawCount || rawIndex < 0) {\n    return -1;\n  }\n\n  if (!this._indices) {\n    return rawIndex;\n  } // Indices are ascending\n\n\n  var indices = this._indices; // If rawIndex === dataIndex\n\n  var rawDataIndex = indices[rawIndex];\n\n  if (rawDataIndex != null && rawDataIndex < this._count && rawDataIndex === rawIndex) {\n    return rawIndex;\n  }\n\n  var left = 0;\n  var right = this._count - 1;\n\n  while (left <= right) {\n    var mid = (left + right) / 2 | 0;\n\n    if (indices[mid] < rawIndex) {\n      left = mid + 1;\n    } else if (indices[mid] > rawIndex) {\n      right = mid - 1;\n    } else {\n      return mid;\n    }\n  }\n\n  return -1;\n};\n/**\n * Retreive the index of nearest value\n * @param {string} dim\n * @param {number} value\n * @param {number} [maxDistance=Infinity]\n * @return {Array.<number>} Considere multiple points has the same value.\n */\n\n\nlistProto.indicesOfNearest = function (dim, value, maxDistance) {\n  var storage = this._storage;\n  var dimData = storage[dim];\n  var nearestIndices = [];\n\n  if (!dimData) {\n    return nearestIndices;\n  }\n\n  if (maxDistance == null) {\n    maxDistance = Infinity;\n  }\n\n  var minDist = Number.MAX_VALUE;\n  var minDiff = -1;\n\n  for (var i = 0, len = this.count(); i < len; i++) {\n    var diff = value - this.get(dim, i\n    /*, stack */\n    );\n    var dist = Math.abs(diff);\n\n    if (diff <= maxDistance && dist <= minDist) {\n      // For the case of two data are same on xAxis, which has sequence data.\n      // Show the nearest index\n      // https://github.com/ecomfe/echarts/issues/2869\n      if (dist < minDist || diff >= 0 && minDiff < 0) {\n        minDist = dist;\n        minDiff = diff;\n        nearestIndices.length = 0;\n      }\n\n      nearestIndices.push(i);\n    }\n  }\n\n  return nearestIndices;\n};\n/**\n * Get raw data index\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawIndex = getRawIndexWithoutIndices;\n\nfunction getRawIndexWithoutIndices(idx) {\n  return idx;\n}\n\nfunction getRawIndexWithIndices(idx) {\n  if (idx < this._count && idx >= 0) {\n    return this._indices[idx];\n  }\n\n  return -1;\n}\n/**\n * Get raw data item\n * @param {number} idx\n * @return {number}\n */\n\n\nlistProto.getRawDataItem = function (idx) {\n  if (!this._rawData.persistent) {\n    var val = [];\n\n    for (var i = 0; i < this.dimensions.length; i++) {\n      var dim = this.dimensions[i];\n      val.push(this.get(dim, idx));\n    }\n\n    return val;\n  } else {\n    return this._rawData.getItem(this.getRawIndex(idx));\n  }\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getName = function (idx) {\n  var rawIndex = this.getRawIndex(idx);\n  return this._nameList[rawIndex] || getRawValueFromStore(this, this._nameDimIdx, rawIndex) || '';\n};\n/**\n * @param {number} idx\n * @param {boolean} [notDefaultIdx=false]\n * @return {string}\n */\n\n\nlistProto.getId = function (idx) {\n  return getId(this, this.getRawIndex(idx));\n};\n\nfunction getId(list, rawIndex) {\n  var id = list._idList[rawIndex];\n\n  if (id == null) {\n    id = getRawValueFromStore(list, list._idDimIdx, rawIndex);\n  }\n\n  if (id == null) {\n    // FIXME Check the usage in graph, should not use prefix.\n    id = ID_PREFIX + rawIndex;\n  }\n\n  return id;\n}\n\nfunction normalizeDimensions(dimensions) {\n  if (!zrUtil.isArray(dimensions)) {\n    dimensions = [dimensions];\n  }\n\n  return dimensions;\n}\n\nfunction validateDimensions(list, dims) {\n  for (var i = 0; i < dims.length; i++) {\n    // stroage may be empty when no data, so use\n    // dimensionInfos to check.\n    if (!list._dimensionInfos[dims[i]]) {\n      console.error('Unkown dimension ' + dims[i]);\n    }\n  }\n}\n/**\n * Data iteration\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n *\n * @example\n *  list.each('x', function (x, idx) {});\n *  list.each(['x', 'y'], function (x, y, idx) {});\n *  list.each(function (idx) {})\n */\n\n\nlistProto.each = function (dims, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dims === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dims;\n    dims = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dims = zrUtil.map(normalizeDimensions(dims), this.getDimension, this);\n  var dimSize = dims.length;\n\n  for (var i = 0; i < this.count(); i++) {\n    // Simple optimization\n    switch (dimSize) {\n      case 0:\n        cb.call(context, i);\n        break;\n\n      case 1:\n        cb.call(context, this.get(dims[0], i), i);\n        break;\n\n      case 2:\n        cb.call(context, this.get(dims[0], i), this.get(dims[1], i), i);\n        break;\n\n      default:\n        var k = 0;\n        var value = [];\n\n        for (; k < dimSize; k++) {\n          value[k] = this.get(dims[k], i);\n        } // Index\n\n\n        value[k] = i;\n        cb.apply(context, value);\n    }\n  }\n};\n/**\n * Data filter\n * @param {string|Array.<string>}\n * @param {Function} cb\n * @param {*} [context=this]\n */\n\n\nlistProto.filterSelf = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var count = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(count);\n  var value = [];\n  var dimSize = dimensions.length;\n  var offset = 0;\n  var dim0 = dimensions[0];\n\n  for (var i = 0; i < count; i++) {\n    var keep;\n    var rawIdx = this.getRawIndex(i); // Simple optimization\n\n    if (dimSize === 0) {\n      keep = cb.call(context, i);\n    } else if (dimSize === 1) {\n      var val = this._getFast(dim0, rawIdx);\n\n      keep = cb.call(context, val, i);\n    } else {\n      for (var k = 0; k < dimSize; k++) {\n        value[k] = this._getFast(dim0, rawIdx);\n      }\n\n      value[k] = i;\n      keep = cb.apply(context, value);\n    }\n\n    if (keep) {\n      newIndices[offset++] = rawIdx;\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < count) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Select data in range. (For optimization of filter)\n * (Manually inline code, support 5 million data filtering in data zoom.)\n */\n\n\nlistProto.selectRange = function (range) {\n  'use strict';\n\n  if (!this._count) {\n    return;\n  }\n\n  var dimensions = [];\n\n  for (var dim in range) {\n    if (range.hasOwnProperty(dim)) {\n      dimensions.push(dim);\n    }\n  }\n\n  var dimSize = dimensions.length;\n\n  if (!dimSize) {\n    return;\n  }\n\n  var originalCount = this.count();\n  var Ctor = getIndicesCtor(this);\n  var newIndices = new Ctor(originalCount);\n  var offset = 0;\n  var dim0 = dimensions[0];\n  var min = range[dim0][0];\n  var max = range[dim0][1];\n  var quickFinished = false;\n\n  if (!this._indices) {\n    // Extreme optimization for common case. About 2x faster in chrome.\n    var idx = 0;\n\n    if (dimSize === 1) {\n      var dimStorage = this._storage[dimensions[0]];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i]; // NaN will not be filtered. Consider the case, in line chart, empty\n          // value indicates the line should be broken. But for the case like\n          // scatter plot, a data item with empty value will not be rendered,\n          // but the axis extent may be effected if some other dim of the data\n          // item has value. Fortunately it is not a significant negative effect.\n\n          if (val >= min && val <= max || isNaN(val)) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    } else if (dimSize === 2) {\n      var dimStorage = this._storage[dim0];\n      var dimStorage2 = this._storage[dimensions[1]];\n      var min2 = range[dimensions[1]][0];\n      var max2 = range[dimensions[1]][1];\n\n      for (var k = 0; k < this._chunkCount; k++) {\n        var chunkStorage = dimStorage[k];\n        var chunkStorage2 = dimStorage2[k];\n        var len = Math.min(this._count - k * this._chunkSize, this._chunkSize);\n\n        for (var i = 0; i < len; i++) {\n          var val = chunkStorage[i];\n          var val2 = chunkStorage2[i]; // Do not filter NaN, see comment above.\n\n          if ((val >= min && val <= max || isNaN(val)) && (val2 >= min2 && val2 <= max2 || isNaN(val2))) {\n            newIndices[offset++] = idx;\n          }\n\n          idx++;\n        }\n      }\n\n      quickFinished = true;\n    }\n  }\n\n  if (!quickFinished) {\n    if (dimSize === 1) {\n      for (var i = 0; i < originalCount; i++) {\n        var rawIndex = this.getRawIndex(i);\n\n        var val = this._getFast(dim0, rawIndex); // Do not filter NaN, see comment above.\n\n\n        if (val >= min && val <= max || isNaN(val)) {\n          newIndices[offset++] = rawIndex;\n        }\n      }\n    } else {\n      for (var i = 0; i < originalCount; i++) {\n        var keep = true;\n        var rawIndex = this.getRawIndex(i);\n\n        for (var k = 0; k < dimSize; k++) {\n          var dimk = dimensions[k];\n\n          var val = this._getFast(dim, rawIndex); // Do not filter NaN, see comment above.\n\n\n          if (val < range[dimk][0] || val > range[dimk][1]) {\n            keep = false;\n          }\n        }\n\n        if (keep) {\n          newIndices[offset++] = this.getRawIndex(i);\n        }\n      }\n    }\n  } // Set indices after filtered.\n\n\n  if (offset < originalCount) {\n    this._indices = newIndices;\n  }\n\n  this._count = offset; // Reset data extent\n\n  this._extent = {};\n  this.getRawIndex = this._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return this;\n};\n/**\n * Data mapping to a plain array\n * @param {string|Array.<string>} [dimensions]\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.mapArray = function (dimensions, cb, context, contextCompat) {\n  'use strict';\n\n  if (typeof dimensions === 'function') {\n    contextCompat = context;\n    context = cb;\n    cb = dimensions;\n    dimensions = [];\n  } // contextCompat just for compat echarts3\n\n\n  context = context || contextCompat || this;\n  var result = [];\n  this.each(dimensions, function () {\n    result.push(cb && cb.apply(this, arguments));\n  }, context);\n  return result;\n}; // Data in excludeDimensions is copied, otherwise transfered.\n\n\nfunction cloneListForMapAndSample(original, excludeDimensions) {\n  var allDimensions = original.dimensions;\n  var list = new List(zrUtil.map(allDimensions, original.getDimensionInfo, original), original.hostModel); // FIXME If needs stackedOn, value may already been stacked\n\n  transferProperties(list, original);\n  var storage = list._storage = {};\n  var originalStorage = original._storage; // Init storage\n\n  for (var i = 0; i < allDimensions.length; i++) {\n    var dim = allDimensions[i];\n\n    if (originalStorage[dim]) {\n      // Notice that we do not reset invertedIndicesMap here, becuase\n      // there is no scenario of mapping or sampling ordinal dimension.\n      if (zrUtil.indexOf(excludeDimensions, dim) >= 0) {\n        storage[dim] = cloneDimStore(originalStorage[dim]);\n        list._rawExtent[dim] = getInitialExtent();\n        list._extent[dim] = null;\n      } else {\n        // Direct reference for other dimensions\n        storage[dim] = originalStorage[dim];\n      }\n    }\n  }\n\n  return list;\n}\n\nfunction cloneDimStore(originalDimStore) {\n  var newDimStore = new Array(originalDimStore.length);\n\n  for (var j = 0; j < originalDimStore.length; j++) {\n    newDimStore[j] = cloneChunk(originalDimStore[j]);\n  }\n\n  return newDimStore;\n}\n\nfunction getInitialExtent() {\n  return [Infinity, -Infinity];\n}\n/**\n * Data mapping to a new List with given dimensions\n * @param {string|Array.<string>} dimensions\n * @param {Function} cb\n * @param {*} [context=this]\n * @return {Array}\n */\n\n\nlistProto.map = function (dimensions, cb, context, contextCompat) {\n  'use strict'; // contextCompat just for compat echarts3\n\n  context = context || contextCompat || this;\n  dimensions = zrUtil.map(normalizeDimensions(dimensions), this.getDimension, this);\n  var list = cloneListForMapAndSample(this, dimensions); // Following properties are all immutable.\n  // So we can reference to the same value\n\n  list._indices = this._indices;\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  var storage = list._storage;\n  var tmpRetValue = [];\n  var chunkSize = this._chunkSize;\n  var dimSize = dimensions.length;\n  var dataCount = this.count();\n  var values = [];\n  var rawExtent = list._rawExtent;\n\n  for (var dataIndex = 0; dataIndex < dataCount; dataIndex++) {\n    for (var dimIndex = 0; dimIndex < dimSize; dimIndex++) {\n      values[dimIndex] = this.get(dimensions[dimIndex], dataIndex\n      /*, stack */\n      );\n    }\n\n    values[dimSize] = dataIndex;\n    var retValue = cb && cb.apply(context, values);\n\n    if (retValue != null) {\n      // a number or string (in oridinal dimension)?\n      if (typeof retValue !== 'object') {\n        tmpRetValue[0] = retValue;\n        retValue = tmpRetValue;\n      }\n\n      var rawIndex = this.getRawIndex(dataIndex);\n      var chunkIndex = Math.floor(rawIndex / chunkSize);\n      var chunkOffset = rawIndex % chunkSize;\n\n      for (var i = 0; i < retValue.length; i++) {\n        var dim = dimensions[i];\n        var val = retValue[i];\n        var rawExtentOnDim = rawExtent[dim];\n        var dimStore = storage[dim];\n\n        if (dimStore) {\n          dimStore[chunkIndex][chunkOffset] = val;\n        }\n\n        if (val < rawExtentOnDim[0]) {\n          rawExtentOnDim[0] = val;\n        }\n\n        if (val > rawExtentOnDim[1]) {\n          rawExtentOnDim[1] = val;\n        }\n      }\n    }\n  }\n\n  return list;\n};\n/**\n * Large data down sampling on given dimension\n * @param {string} dimension\n * @param {number} rate\n * @param {Function} sampleValue\n * @param {Function} sampleIndex Sample index for name and id\n */\n\n\nlistProto.downSample = function (dimension, rate, sampleValue, sampleIndex) {\n  var list = cloneListForMapAndSample(this, [dimension]);\n  var targetStorage = list._storage;\n  var frameValues = [];\n  var frameSize = Math.floor(1 / rate);\n  var dimStore = targetStorage[dimension];\n  var len = this.count();\n  var chunkSize = this._chunkSize;\n  var rawExtentOnDim = list._rawExtent[dimension];\n  var newIndices = new (getIndicesCtor(this))(len);\n  var offset = 0;\n\n  for (var i = 0; i < len; i += frameSize) {\n    // Last frame\n    if (frameSize > len - i) {\n      frameSize = len - i;\n      frameValues.length = frameSize;\n    }\n\n    for (var k = 0; k < frameSize; k++) {\n      var dataIdx = this.getRawIndex(i + k);\n      var originalChunkIndex = Math.floor(dataIdx / chunkSize);\n      var originalChunkOffset = dataIdx % chunkSize;\n      frameValues[k] = dimStore[originalChunkIndex][originalChunkOffset];\n    }\n\n    var value = sampleValue(frameValues);\n    var sampleFrameIdx = this.getRawIndex(Math.min(i + sampleIndex(frameValues, value) || 0, len - 1));\n    var sampleChunkIndex = Math.floor(sampleFrameIdx / chunkSize);\n    var sampleChunkOffset = sampleFrameIdx % chunkSize; // Only write value on the filtered data\n\n    dimStore[sampleChunkIndex][sampleChunkOffset] = value;\n\n    if (value < rawExtentOnDim[0]) {\n      rawExtentOnDim[0] = value;\n    }\n\n    if (value > rawExtentOnDim[1]) {\n      rawExtentOnDim[1] = value;\n    }\n\n    newIndices[offset++] = sampleFrameIdx;\n  }\n\n  list._count = offset;\n  list._indices = newIndices;\n  list.getRawIndex = getRawIndexWithIndices;\n  return list;\n};\n/**\n * Get model of one data item.\n *\n * @param {number} idx\n */\n// FIXME Model proxy ?\n\n\nlistProto.getItemModel = function (idx) {\n  var hostModel = this.hostModel;\n  return new Model(this.getRawDataItem(idx), hostModel, hostModel && hostModel.ecModel);\n};\n/**\n * Create a data differ\n * @param {module:echarts/data/List} otherList\n * @return {module:echarts/data/DataDiffer}\n */\n\n\nlistProto.diff = function (otherList) {\n  var thisList = this;\n  return new DataDiffer(otherList ? otherList.getIndices() : [], this.getIndices(), function (idx) {\n    return getId(otherList, idx);\n  }, function (idx) {\n    return getId(thisList, idx);\n  });\n};\n/**\n * Get visual property.\n * @param {string} key\n */\n\n\nlistProto.getVisual = function (key) {\n  var visual = this._visual;\n  return visual && visual[key];\n};\n/**\n * Set visual property\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setVisual('color', color);\n *  setVisual({\n *      'color': color\n *  });\n */\n\n\nlistProto.setVisual = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setVisual(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._visual = this._visual || {};\n  this._visual[key] = val;\n};\n/**\n * Set layout property.\n * @param {string|Object} key\n * @param {*} [val]\n */\n\n\nlistProto.setLayout = function (key, val) {\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        this.setLayout(name, key[name]);\n      }\n    }\n\n    return;\n  }\n\n  this._layout[key] = val;\n};\n/**\n * Get layout property.\n * @param  {string} key.\n * @return {*}\n */\n\n\nlistProto.getLayout = function (key) {\n  return this._layout[key];\n};\n/**\n * Get layout of single data item\n * @param {number} idx\n */\n\n\nlistProto.getItemLayout = function (idx) {\n  return this._itemLayouts[idx];\n};\n/**\n * Set layout of single data item\n * @param {number} idx\n * @param {Object} layout\n * @param {boolean=} [merge=false]\n */\n\n\nlistProto.setItemLayout = function (idx, layout, merge) {\n  this._itemLayouts[idx] = merge ? zrUtil.extend(this._itemLayouts[idx] || {}, layout) : layout;\n};\n/**\n * Clear all layout of single data item\n */\n\n\nlistProto.clearItemLayouts = function () {\n  this._itemLayouts.length = 0;\n};\n/**\n * Get visual property of single data item\n * @param {number} idx\n * @param {string} key\n * @param {boolean} [ignoreParent=false]\n */\n\n\nlistProto.getItemVisual = function (idx, key, ignoreParent) {\n  var itemVisual = this._itemVisuals[idx];\n  var val = itemVisual && itemVisual[key];\n\n  if (val == null && !ignoreParent) {\n    // Use global visual property\n    return this.getVisual(key);\n  }\n\n  return val;\n};\n/**\n * Set visual property of single data item\n *\n * @param {number} idx\n * @param {string|Object} key\n * @param {*} [value]\n *\n * @example\n *  setItemVisual(0, 'color', color);\n *  setItemVisual(0, {\n *      'color': color\n *  });\n */\n\n\nlistProto.setItemVisual = function (idx, key, value) {\n  var itemVisual = this._itemVisuals[idx] || {};\n  var hasItemVisual = this.hasItemVisual;\n  this._itemVisuals[idx] = itemVisual;\n\n  if (isObject(key)) {\n    for (var name in key) {\n      if (key.hasOwnProperty(name)) {\n        itemVisual[name] = key[name];\n        hasItemVisual[name] = true;\n      }\n    }\n\n    return;\n  }\n\n  itemVisual[key] = value;\n  hasItemVisual[key] = true;\n};\n/**\n * Clear itemVisuals and list visual.\n */\n\n\nlistProto.clearAllVisual = function () {\n  this._visual = {};\n  this._itemVisuals = [];\n  this.hasItemVisual = {};\n};\n\nvar setItemDataAndSeriesIndex = function (child) {\n  child.seriesIndex = this.seriesIndex;\n  child.dataIndex = this.dataIndex;\n  child.dataType = this.dataType;\n};\n/**\n * Set graphic element relative to data. It can be set as null\n * @param {number} idx\n * @param {module:zrender/Element} [el]\n */\n\n\nlistProto.setItemGraphicEl = function (idx, el) {\n  var hostModel = this.hostModel;\n\n  if (el) {\n    // Add data index and series index for indexing the data by element\n    // Useful in tooltip\n    el.dataIndex = idx;\n    el.dataType = this.dataType;\n    el.seriesIndex = hostModel && hostModel.seriesIndex;\n\n    if (el.type === 'group') {\n      el.traverse(setItemDataAndSeriesIndex, el);\n    }\n  }\n\n  this._graphicEls[idx] = el;\n};\n/**\n * @param {number} idx\n * @return {module:zrender/Element}\n */\n\n\nlistProto.getItemGraphicEl = function (idx) {\n  return this._graphicEls[idx];\n};\n/**\n * @param {Function} cb\n * @param {*} context\n */\n\n\nlistProto.eachItemGraphicEl = function (cb, context) {\n  zrUtil.each(this._graphicEls, function (el, idx) {\n    if (el) {\n      cb && cb.call(context, el, idx);\n    }\n  });\n};\n/**\n * Shallow clone a new list except visual and layout properties, and graph elements.\n * New list only change the indices.\n */\n\n\nlistProto.cloneShallow = function (list) {\n  if (!list) {\n    var dimensionInfoList = zrUtil.map(this.dimensions, this.getDimensionInfo, this);\n    list = new List(dimensionInfoList, this.hostModel);\n  } // FIXME\n\n\n  list._storage = this._storage;\n  transferProperties(list, this); // Clone will not change the data extent and indices\n\n  if (this._indices) {\n    var Ctor = this._indices.constructor;\n    list._indices = new Ctor(this._indices);\n  } else {\n    list._indices = null;\n  }\n\n  list.getRawIndex = list._indices ? getRawIndexWithIndices : getRawIndexWithoutIndices;\n  return list;\n};\n/**\n * Wrap some method to add more feature\n * @param {string} methodName\n * @param {Function} injectFunction\n */\n\n\nlistProto.wrapMethod = function (methodName, injectFunction) {\n  var originalMethod = this[methodName];\n\n  if (typeof originalMethod !== 'function') {\n    return;\n  }\n\n  this.__wrappedMethods = this.__wrappedMethods || [];\n\n  this.__wrappedMethods.push(methodName);\n\n  this[methodName] = function () {\n    var res = originalMethod.apply(this, arguments);\n    return injectFunction.apply(this, [res].concat(zrUtil.slice(arguments)));\n  };\n}; // Methods that create a new list based on this list should be listed here.\n// Notice that those method should `RETURN` the new list.\n\n\nlistProto.TRANSFERABLE_METHODS = ['cloneShallow', 'downSample', 'map']; // Methods that change indices of this list should be listed here.\n\nlistProto.CHANGABLE_METHODS = ['filterSelf', 'selectRange'];\nvar _default = List;\nmodule.exports = _default;"],"mappings":"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EAClB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAAC0C,QAAQ,GAAG,CAAC,CAAC;EAClB;AACF;AACA;;EAEE,IAAI,CAACC,SAAS,GAAG,EAAE;EACnB;AACF;AACA;;EAEE,IAAI,CAACC,OAAO,GAAG,EAAE;EACjB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,aAAa,GAAG,EAAE;EACvB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;EACjB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;EACjB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,YAAY,GAAG,EAAE;EACtB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,aAAa,GAAG,CAAC,CAAC;EACvB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,YAAY,GAAG,EAAE;EACtB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,WAAW,GAAG,EAAE;EACrB;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,UAAU,GAAG,GAAG;EACrB;AACF;AACA;AACA;;EAEE,IAAI,CAACC,WAAW,GAAG,CAAC;EACpB;AACF;AACA;AACA;;EAEE,IAAI,CAACC,QAAQ;EACb;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;EAEE,IAAI,CAACC,UAAU,GAAG,CAAC,CAAC;EACpB;AACF;AACA;AACA;;EAEE,IAAI,CAACC,OAAO,GAAG,CAAC,CAAC;EACjB;AACF;AACA;AACA;AACA;AACA;;EAEE,IAAI,CAACC,kBAAkB,GAAG,CAAC,CAAC;EAC5B;AACF;AACA;AACA;AACA;;EAEE,IAAI,CAACC,kBAAkB,GAAG1E,mBAAmB,CAAC,IAAI,CAAC;EACnD;AACF;AACA;AACA;;EAEE,IAAI,CAAC2E,mBAAmB,GAAGnC,kBAAkB;EAC7C;AACF;AACA;AACA;;EAEE,IAAI,CAACP,gBAAgB,GAAG,CAAC,CAAC;EAC1B;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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"},"metadata":{},"sourceType":"script","externalDependencies":[]}