{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar layout = require(\"../../util/layout\");\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar _model = require(\"../../util/model\");\nvar groupData = _model.groupData;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel, api, payload) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = zrUtil.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    var orient = seriesModel.get('orient');\n    var nodeAlign = seriesModel.get('nodeAlign');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);\n  });\n}\n/**\n * Get the layout position of the whole view\n *\n * @param {module:echarts/model/Series} seriesModel  the model object of sankey series\n * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call\n * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view\n */\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {\n  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);\n  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);\n  computeEdgeDepths(nodes, orient);\n}\n/**\n * Compute the value of each node by summing the associated edge's value\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\nfunction computeNodeValues(nodes) {\n  zrUtil.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var value = Math.max(value1, value2);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\n * Compute the x-position for each node.\n *\n * Here we use Kahn algorithm to detect cycle when we traverse\n * the node to computer the initial x position.\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param  {number} nodeWidth  the dx of the node\n * @param  {number} width  the whole width of the area to draw the view\n */\n\nfunction computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {\n  // Used to mark whether the edge is deleted. if it is deleted,\n  // the value is 0, otherwise it is 1.\n  var remainEdges = []; // Storage each node's indegree.\n\n  var indegreeArr = []; //Used to storage the node with indegree is equal to 0.\n\n  var zeroIndegrees = [];\n  var nextTargetNode = [];\n  var x = 0;\n  var kx = 0;\n  for (var i = 0; i < edges.length; i++) {\n    remainEdges[i] = 1;\n  }\n  for (i = 0; i < nodes.length; i++) {\n    indegreeArr[i] = nodes[i].inEdges.length;\n    if (indegreeArr[i] === 0) {\n      zeroIndegrees.push(nodes[i]);\n    }\n  }\n  var maxNodeDepth = -1; // Traversing nodes using topological sorting to calculate the\n  // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')\n  // position of the nodes.\n\n  while (zeroIndegrees.length) {\n    for (var idx = 0; idx < zeroIndegrees.length; idx++) {\n      var node = zeroIndegrees[idx];\n      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n      var isItemDepth = item.depth != null && item.depth >= 0;\n      if (isItemDepth && item.depth > maxNodeDepth) {\n        maxNodeDepth = item.depth;\n      }\n      node.setLayout({\n        depth: isItemDepth ? item.depth : x\n      }, true);\n      orient === 'vertical' ? node.setLayout({\n        dy: nodeWidth\n      }, true) : node.setLayout({\n        dx: nodeWidth\n      }, true);\n      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {\n        var edge = node.outEdges[edgeIdx];\n        var indexEdge = edges.indexOf(edge);\n        remainEdges[indexEdge] = 0;\n        var targetNode = edge.node2;\n        var nodeIndex = nodes.indexOf(targetNode);\n        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {\n          nextTargetNode.push(targetNode);\n        }\n      }\n    }\n    ++x;\n    zeroIndegrees = nextTargetNode;\n    nextTargetNode = [];\n  }\n  for (i = 0; i < remainEdges.length; i++) {\n    if (remainEdges[i] === 1) {\n      throw new Error('Sankey is a DAG, the original data has cycle!');\n    }\n  }\n  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;\n  if (nodeAlign && nodeAlign !== 'left') {\n    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);\n  }\n  var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;\n  scaleNodeBreadths(nodes, kx, orient);\n}\nfunction isNodeDepth(node) {\n  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n  return item.depth != null && item.depth >= 0;\n}\nfunction adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {\n  if (nodeAlign === 'right') {\n    var nextSourceNode = [];\n    var remainNodes = nodes;\n    var nodeHeight = 0;\n    while (remainNodes.length) {\n      for (var i = 0; i < remainNodes.length; i++) {\n        var node = remainNodes[i];\n        node.setLayout({\n          skNodeHeight: nodeHeight\n        }, true);\n        for (var j = 0; j < node.inEdges.length; j++) {\n          var edge = node.inEdges[j];\n          if (nextSourceNode.indexOf(edge.node1) < 0) {\n            nextSourceNode.push(edge.node1);\n          }\n        }\n      }\n      remainNodes = nextSourceNode;\n      nextSourceNode = [];\n      ++nodeHeight;\n    }\n    zrUtil.each(nodes, function (node) {\n      if (!isNodeDepth(node)) {\n        node.setLayout({\n          depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)\n        }, true);\n      }\n    });\n  } else if (nodeAlign === 'justify') {\n    moveSinksRight(nodes, maxDepth);\n  }\n}\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param {module:echarts/data/Graph~Node} nodes.  node of sankey view.\n * @param {number} maxDepth.  use to assign to node without outEdges as x-position.\n */\n\nfunction moveSinksRight(nodes, maxDepth) {\n  zrUtil.each(nodes, function (node) {\n    if (!isNodeDepth(node) && !node.outEdges.length) {\n      node.setLayout({\n        depth: maxDepth\n      }, true);\n    }\n  });\n}\n/**\n * Scale node x-position to the width\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} kx   multiple used to scale nodes\n */\n\nfunction scaleNodeBreadths(nodes, kx, orient) {\n  zrUtil.each(nodes, function (node) {\n    var nodeDepth = node.getLayout().depth * kx;\n    orient === 'vertical' ? node.setLayout({\n      y: nodeDepth\n    }, true) : node.setLayout({\n      x: nodeDepth\n    }, true);\n  });\n}\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param {number} iterations  the number of iterations for the algorithm\n */\n\nfunction computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {\n  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);\n  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);\n  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n    relaxLeftToRight(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  }\n}\nfunction prepareNodesByBreadth(nodes, orient) {\n  var nodesByBreadth = [];\n  var keyAttr = orient === 'vertical' ? 'y' : 'x';\n  var groupResult = groupData(nodes, function (node) {\n    return node.getLayout()[keyAttr];\n  });\n  groupResult.keys.sort(function (a, b) {\n    return a - b;\n  });\n  zrUtil.each(groupResult.keys, function (key) {\n    nodesByBreadth.push(groupResult.buckets.get(key));\n  });\n  return nodesByBreadth;\n}\n/**\n * Compute the original y-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n */\n\nfunction initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {\n  var minKy = Infinity;\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    zrUtil.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;\n    if (ky < minKy) {\n      minKy = ky;\n    }\n  });\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node, i) {\n      var nodeDy = node.getLayout().value * minKy;\n      if (orient === 'vertical') {\n        node.setLayout({\n          x: i\n        }, true);\n        node.setLayout({\n          dx: nodeDy\n        }, true);\n      } else {\n        node.setLayout({\n          y: i\n        }, true);\n        node.setLayout({\n          dy: nodeDy\n        }, true);\n      }\n    });\n  });\n  zrUtil.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * minKy;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\n * Resolve the collision of initialized depth (y-position)\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {number} nodeGap  the vertical distance between two nodes\n * @param {number} height  the whole height of the area to draw the view\n */\n\nfunction resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    nodes.sort(function (a, b) {\n      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];\n    });\n    var nodeX;\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';\n    for (var i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout()[keyAttr];\n      if (dy > 0) {\n        nodeX = node.getLayout()[keyAttr] + dy;\n        orient === 'vertical' ? node.setLayout({\n          x: nodeX\n        }, true) : node.setLayout({\n          y: nodeX\n        }, true);\n      }\n      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;\n    }\n    var viewWidth = orient === 'vertical' ? width : height; // If the bottommost node goes outside the bounds, push it back up\n\n    dy = y0 - nodeGap - viewWidth;\n    if (dy > 0) {\n      nodeX = node.getLayout()[keyAttr] - dy;\n      orient === 'vertical' ? node.setLayout({\n        x: nodeX\n      }, true) : node.setLayout({\n        y: nodeX\n      }, true);\n      y0 = nodeX;\n      for (i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;\n        if (dy > 0) {\n          nodeX = node.getLayout()[keyAttr] - dy;\n          orient === 'vertical' ? node.setLayout({\n            x: nodeX\n          }, true) : node.setLayout({\n            y: nodeX\n          }, true);\n        }\n        y0 = node.getLayout()[keyAttr];\n      }\n    }\n  });\n}\n/**\n * Change the y-position of the nodes, except most the right side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\nfunction relaxRightToLeft(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue, orient);\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\nfunction weightedTarget(edge, orient) {\n  return center(edge.node2, orient) * edge.getValue();\n}\nfunction weightedSource(edge, orient) {\n  return center(edge.node1, orient) * edge.getValue();\n}\nfunction center(node, orient) {\n  return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;\n}\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\nfunction sum(array, f, orient) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n  while (++i < len) {\n    var value = +f.call(array, array[i], orient);\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n  return sum;\n}\n/**\n * Change the y-position of the nodes, except most the left side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\nfunction relaxLeftToRight(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue, orient);\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n/**\n * Compute the depth(y-position) of each edge\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\nfunction computeEdgeDepths(nodes, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodes, function (node) {\n    node.outEdges.sort(function (a, b) {\n      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];\n    });\n    node.inEdges.sort(function (a, b) {\n      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];\n    });\n  });\n  zrUtil.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    zrUtil.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    zrUtil.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}\nmodule.exports = _default;","map":{"version":3,"names":["layout","require","zrUtil","_model","groupData","_default","ecModel","api","payload","eachSeriesByType","seriesModel","nodeWidth","get","nodeGap","layoutInfo","getViewRect","width","height","graph","getGraph","nodes","edges","computeNodeValues","filteredNodes","filter","node","getLayout","value","iterations","length","orient","nodeAlign","layoutSankey","getLayoutRect","getBoxLayoutParams","getWidth","getHeight","computeNodeBreadths","computeNodeDepths","computeEdgeDepths","each","value1","sum","outEdges","getEdgeValue","value2","inEdges","Math","max","setLayout","remainEdges","indegreeArr","zeroIndegrees","nextTargetNode","x","kx","i","push","maxNodeDepth","idx","item","hostGraph","data","getRawDataItem","dataIndex","isItemDepth","depth","dy","dx","edgeIdx","edge","indexEdge","indexOf","targetNode","node2","nodeIndex","Error","maxDepth","adjustNodeWithNodeAlign","scaleNodeBreadths","isNodeDepth","nextSourceNode","remainNodes","nodeHeight","skNodeHeight","j","node1","moveSinksRight","nodeDepth","y","nodesByBreadth","prepareNodesByBreadth","initializeNodeDepth","resolveCollisions","alpha","relaxRightToLeft","relaxLeftToRight","keyAttr","groupResult","keys","sort","a","b","key","buckets","minKy","Infinity","n","ky","nodeDy","edgeDy","getValue","nodeX","y0","nodeDyAttr","viewWidth","slice","reverse","weightedTarget","center","nodeY","weightedSource","array","f","len","call","isNaN","sy","ty","module","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/chart/sankey/sankeyLayout.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar layout = require(\"../../util/layout\");\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar _model = require(\"../../util/model\");\n\nvar groupData = _model.groupData;\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nfunction _default(ecModel, api, payload) {\n  ecModel.eachSeriesByType('sankey', function (seriesModel) {\n    var nodeWidth = seriesModel.get('nodeWidth');\n    var nodeGap = seriesModel.get('nodeGap');\n    var layoutInfo = getViewRect(seriesModel, api);\n    seriesModel.layoutInfo = layoutInfo;\n    var width = layoutInfo.width;\n    var height = layoutInfo.height;\n    var graph = seriesModel.getGraph();\n    var nodes = graph.nodes;\n    var edges = graph.edges;\n    computeNodeValues(nodes);\n    var filteredNodes = zrUtil.filter(nodes, function (node) {\n      return node.getLayout().value === 0;\n    });\n    var iterations = filteredNodes.length !== 0 ? 0 : seriesModel.get('layoutIterations');\n    var orient = seriesModel.get('orient');\n    var nodeAlign = seriesModel.get('nodeAlign');\n    layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign);\n  });\n}\n/**\n * Get the layout position of the whole view\n *\n * @param {module:echarts/model/Series} seriesModel  the model object of sankey series\n * @param {module:echarts/ExtensionAPI} api  provide the API list that the developer can call\n * @return {module:zrender/core/BoundingRect}  size of rect to draw the sankey view\n */\n\n\nfunction getViewRect(seriesModel, api) {\n  return layout.getLayoutRect(seriesModel.getBoxLayoutParams(), {\n    width: api.getWidth(),\n    height: api.getHeight()\n  });\n}\n\nfunction layoutSankey(nodes, edges, nodeWidth, nodeGap, width, height, iterations, orient, nodeAlign) {\n  computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign);\n  computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient);\n  computeEdgeDepths(nodes, orient);\n}\n/**\n * Compute the value of each node by summing the associated edge's value\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\n\nfunction computeNodeValues(nodes) {\n  zrUtil.each(nodes, function (node) {\n    var value1 = sum(node.outEdges, getEdgeValue);\n    var value2 = sum(node.inEdges, getEdgeValue);\n    var value = Math.max(value1, value2);\n    node.setLayout({\n      value: value\n    }, true);\n  });\n}\n/**\n * Compute the x-position for each node.\n *\n * Here we use Kahn algorithm to detect cycle when we traverse\n * the node to computer the initial x position.\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param  {number} nodeWidth  the dx of the node\n * @param  {number} width  the whole width of the area to draw the view\n */\n\n\nfunction computeNodeBreadths(nodes, edges, nodeWidth, width, height, orient, nodeAlign) {\n  // Used to mark whether the edge is deleted. if it is deleted,\n  // the value is 0, otherwise it is 1.\n  var remainEdges = []; // Storage each node's indegree.\n\n  var indegreeArr = []; //Used to storage the node with indegree is equal to 0.\n\n  var zeroIndegrees = [];\n  var nextTargetNode = [];\n  var x = 0;\n  var kx = 0;\n\n  for (var i = 0; i < edges.length; i++) {\n    remainEdges[i] = 1;\n  }\n\n  for (i = 0; i < nodes.length; i++) {\n    indegreeArr[i] = nodes[i].inEdges.length;\n\n    if (indegreeArr[i] === 0) {\n      zeroIndegrees.push(nodes[i]);\n    }\n  }\n\n  var maxNodeDepth = -1; // Traversing nodes using topological sorting to calculate the\n  // horizontal(if orient === 'horizontal') or vertical(if orient === 'vertical')\n  // position of the nodes.\n\n  while (zeroIndegrees.length) {\n    for (var idx = 0; idx < zeroIndegrees.length; idx++) {\n      var node = zeroIndegrees[idx];\n      var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n      var isItemDepth = item.depth != null && item.depth >= 0;\n\n      if (isItemDepth && item.depth > maxNodeDepth) {\n        maxNodeDepth = item.depth;\n      }\n\n      node.setLayout({\n        depth: isItemDepth ? item.depth : x\n      }, true);\n      orient === 'vertical' ? node.setLayout({\n        dy: nodeWidth\n      }, true) : node.setLayout({\n        dx: nodeWidth\n      }, true);\n\n      for (var edgeIdx = 0; edgeIdx < node.outEdges.length; edgeIdx++) {\n        var edge = node.outEdges[edgeIdx];\n        var indexEdge = edges.indexOf(edge);\n        remainEdges[indexEdge] = 0;\n        var targetNode = edge.node2;\n        var nodeIndex = nodes.indexOf(targetNode);\n\n        if (--indegreeArr[nodeIndex] === 0 && nextTargetNode.indexOf(targetNode) < 0) {\n          nextTargetNode.push(targetNode);\n        }\n      }\n    }\n\n    ++x;\n    zeroIndegrees = nextTargetNode;\n    nextTargetNode = [];\n  }\n\n  for (i = 0; i < remainEdges.length; i++) {\n    if (remainEdges[i] === 1) {\n      throw new Error('Sankey is a DAG, the original data has cycle!');\n    }\n  }\n\n  var maxDepth = maxNodeDepth > x - 1 ? maxNodeDepth : x - 1;\n\n  if (nodeAlign && nodeAlign !== 'left') {\n    adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth);\n  }\n\n  var kx = orient === 'vertical' ? (height - nodeWidth) / maxDepth : (width - nodeWidth) / maxDepth;\n  scaleNodeBreadths(nodes, kx, orient);\n}\n\nfunction isNodeDepth(node) {\n  var item = node.hostGraph.data.getRawDataItem(node.dataIndex);\n  return item.depth != null && item.depth >= 0;\n}\n\nfunction adjustNodeWithNodeAlign(nodes, nodeAlign, orient, maxDepth) {\n  if (nodeAlign === 'right') {\n    var nextSourceNode = [];\n    var remainNodes = nodes;\n    var nodeHeight = 0;\n\n    while (remainNodes.length) {\n      for (var i = 0; i < remainNodes.length; i++) {\n        var node = remainNodes[i];\n        node.setLayout({\n          skNodeHeight: nodeHeight\n        }, true);\n\n        for (var j = 0; j < node.inEdges.length; j++) {\n          var edge = node.inEdges[j];\n\n          if (nextSourceNode.indexOf(edge.node1) < 0) {\n            nextSourceNode.push(edge.node1);\n          }\n        }\n      }\n\n      remainNodes = nextSourceNode;\n      nextSourceNode = [];\n      ++nodeHeight;\n    }\n\n    zrUtil.each(nodes, function (node) {\n      if (!isNodeDepth(node)) {\n        node.setLayout({\n          depth: Math.max(0, maxDepth - node.getLayout().skNodeHeight)\n        }, true);\n      }\n    });\n  } else if (nodeAlign === 'justify') {\n    moveSinksRight(nodes, maxDepth);\n  }\n}\n/**\n * All the node without outEgdes are assigned maximum x-position and\n *     be aligned in the last column.\n *\n * @param {module:echarts/data/Graph~Node} nodes.  node of sankey view.\n * @param {number} maxDepth.  use to assign to node without outEdges as x-position.\n */\n\n\nfunction moveSinksRight(nodes, maxDepth) {\n  zrUtil.each(nodes, function (node) {\n    if (!isNodeDepth(node) && !node.outEdges.length) {\n      node.setLayout({\n        depth: maxDepth\n      }, true);\n    }\n  });\n}\n/**\n * Scale node x-position to the width\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {number} kx   multiple used to scale nodes\n */\n\n\nfunction scaleNodeBreadths(nodes, kx, orient) {\n  zrUtil.each(nodes, function (node) {\n    var nodeDepth = node.getLayout().depth * kx;\n    orient === 'vertical' ? node.setLayout({\n      y: nodeDepth\n    }, true) : node.setLayout({\n      x: nodeDepth\n    }, true);\n  });\n}\n/**\n * Using Gauss-Seidel iterations method to compute the node depth(y-position)\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n *     in the same column.\n * @param {number} iterations  the number of iterations for the algorithm\n */\n\n\nfunction computeNodeDepths(nodes, edges, height, width, nodeGap, iterations, orient) {\n  var nodesByBreadth = prepareNodesByBreadth(nodes, orient);\n  initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient);\n  resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n\n  for (var alpha = 1; iterations > 0; iterations--) {\n    // 0.99 is a experience parameter, ensure that each iterations of\n    // changes as small as possible.\n    alpha *= 0.99;\n    relaxRightToLeft(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n    relaxLeftToRight(nodesByBreadth, alpha, orient);\n    resolveCollisions(nodesByBreadth, nodeGap, height, width, orient);\n  }\n}\n\nfunction prepareNodesByBreadth(nodes, orient) {\n  var nodesByBreadth = [];\n  var keyAttr = orient === 'vertical' ? 'y' : 'x';\n  var groupResult = groupData(nodes, function (node) {\n    return node.getLayout()[keyAttr];\n  });\n  groupResult.keys.sort(function (a, b) {\n    return a - b;\n  });\n  zrUtil.each(groupResult.keys, function (key) {\n    nodesByBreadth.push(groupResult.buckets.get(key));\n  });\n  return nodesByBreadth;\n}\n/**\n * Compute the original y-position for each node\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {module:echarts/data/Graph~Edge} edges  edge of sankey view\n * @param {number} height  the whole height of the area to draw the view\n * @param {number} nodeGap  the vertical distance between two nodes\n */\n\n\nfunction initializeNodeDepth(nodesByBreadth, edges, height, width, nodeGap, orient) {\n  var minKy = Infinity;\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    var n = nodes.length;\n    var sum = 0;\n    zrUtil.each(nodes, function (node) {\n      sum += node.getLayout().value;\n    });\n    var ky = orient === 'vertical' ? (width - (n - 1) * nodeGap) / sum : (height - (n - 1) * nodeGap) / sum;\n\n    if (ky < minKy) {\n      minKy = ky;\n    }\n  });\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node, i) {\n      var nodeDy = node.getLayout().value * minKy;\n\n      if (orient === 'vertical') {\n        node.setLayout({\n          x: i\n        }, true);\n        node.setLayout({\n          dx: nodeDy\n        }, true);\n      } else {\n        node.setLayout({\n          y: i\n        }, true);\n        node.setLayout({\n          dy: nodeDy\n        }, true);\n      }\n    });\n  });\n  zrUtil.each(edges, function (edge) {\n    var edgeDy = +edge.getValue() * minKy;\n    edge.setLayout({\n      dy: edgeDy\n    }, true);\n  });\n}\n/**\n * Resolve the collision of initialized depth (y-position)\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the nodes x-position.\n * @param {number} nodeGap  the vertical distance between two nodes\n * @param {number} height  the whole height of the area to draw the view\n */\n\n\nfunction resolveCollisions(nodesByBreadth, nodeGap, height, width, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    nodes.sort(function (a, b) {\n      return a.getLayout()[keyAttr] - b.getLayout()[keyAttr];\n    });\n    var nodeX;\n    var node;\n    var dy;\n    var y0 = 0;\n    var n = nodes.length;\n    var nodeDyAttr = orient === 'vertical' ? 'dx' : 'dy';\n\n    for (var i = 0; i < n; i++) {\n      node = nodes[i];\n      dy = y0 - node.getLayout()[keyAttr];\n\n      if (dy > 0) {\n        nodeX = node.getLayout()[keyAttr] + dy;\n        orient === 'vertical' ? node.setLayout({\n          x: nodeX\n        }, true) : node.setLayout({\n          y: nodeX\n        }, true);\n      }\n\n      y0 = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap;\n    }\n\n    var viewWidth = orient === 'vertical' ? width : height; // If the bottommost node goes outside the bounds, push it back up\n\n    dy = y0 - nodeGap - viewWidth;\n\n    if (dy > 0) {\n      nodeX = node.getLayout()[keyAttr] - dy;\n      orient === 'vertical' ? node.setLayout({\n        x: nodeX\n      }, true) : node.setLayout({\n        y: nodeX\n      }, true);\n      y0 = nodeX;\n\n      for (i = n - 2; i >= 0; --i) {\n        node = nodes[i];\n        dy = node.getLayout()[keyAttr] + node.getLayout()[nodeDyAttr] + nodeGap - y0;\n\n        if (dy > 0) {\n          nodeX = node.getLayout()[keyAttr] - dy;\n          orient === 'vertical' ? node.setLayout({\n            x: nodeX\n          }, true) : node.setLayout({\n            y: nodeX\n          }, true);\n        }\n\n        y0 = node.getLayout()[keyAttr];\n      }\n    }\n  });\n}\n/**\n * Change the y-position of the nodes, except most the right side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxRightToLeft(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth.slice().reverse(), function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.outEdges.length) {\n        var y = sum(node.outEdges, weightedTarget, orient) / sum(node.outEdges, getEdgeValue, orient);\n\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n\nfunction weightedTarget(edge, orient) {\n  return center(edge.node2, orient) * edge.getValue();\n}\n\nfunction weightedSource(edge, orient) {\n  return center(edge.node1, orient) * edge.getValue();\n}\n\nfunction center(node, orient) {\n  return orient === 'vertical' ? node.getLayout().x + node.getLayout().dx / 2 : node.getLayout().y + node.getLayout().dy / 2;\n}\n\nfunction getEdgeValue(edge) {\n  return edge.getValue();\n}\n\nfunction sum(array, f, orient) {\n  var sum = 0;\n  var len = array.length;\n  var i = -1;\n\n  while (++i < len) {\n    var value = +f.call(array, array[i], orient);\n\n    if (!isNaN(value)) {\n      sum += value;\n    }\n  }\n\n  return sum;\n}\n/**\n * Change the y-position of the nodes, except most the left side nodes\n *\n * @param {Array.<Array.<module:echarts/data/Graph~Node>>} nodesByBreadth\n *     group by the array of all sankey nodes based on the node x-position.\n * @param {number} alpha  parameter used to adjust the nodes y-position\n */\n\n\nfunction relaxLeftToRight(nodesByBreadth, alpha, orient) {\n  zrUtil.each(nodesByBreadth, function (nodes) {\n    zrUtil.each(nodes, function (node) {\n      if (node.inEdges.length) {\n        var y = sum(node.inEdges, weightedSource, orient) / sum(node.inEdges, getEdgeValue, orient);\n\n        if (orient === 'vertical') {\n          var nodeX = node.getLayout().x + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            x: nodeX\n          }, true);\n        } else {\n          var nodeY = node.getLayout().y + (y - center(node, orient)) * alpha;\n          node.setLayout({\n            y: nodeY\n          }, true);\n        }\n      }\n    });\n  });\n}\n/**\n * Compute the depth(y-position) of each edge\n *\n * @param {module:echarts/data/Graph~Node} nodes  node of sankey view\n */\n\n\nfunction computeEdgeDepths(nodes, orient) {\n  var keyAttr = orient === 'vertical' ? 'x' : 'y';\n  zrUtil.each(nodes, function (node) {\n    node.outEdges.sort(function (a, b) {\n      return a.node2.getLayout()[keyAttr] - b.node2.getLayout()[keyAttr];\n    });\n    node.inEdges.sort(function (a, b) {\n      return a.node1.getLayout()[keyAttr] - b.node1.getLayout()[keyAttr];\n    });\n  });\n  zrUtil.each(nodes, function (node) {\n    var sy = 0;\n    var ty = 0;\n    zrUtil.each(node.outEdges, function (edge) {\n      edge.setLayout({\n        sy: sy\n      }, true);\n      sy += edge.getLayout().dy;\n    });\n    zrUtil.each(node.inEdges, function (edge) {\n      edge.setLayout({\n        ty: ty\n      }, true);\n      ty += edge.getLayout().dy;\n    });\n  });\n}\n\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}