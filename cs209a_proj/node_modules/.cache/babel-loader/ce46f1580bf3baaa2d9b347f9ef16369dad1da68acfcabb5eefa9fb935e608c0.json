{"ast":null,"code":"require(\"core-js/modules/es.array.push.js\");\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\nvar __DEV__ = _config.__DEV__;\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\nvar graphic = require(\"../../util/graphic\");\nvar interactionMutex = require(\"./interactionMutex\");\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._lastMouseMovePoint = {};\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\nBrushController.prototype = {\n  constructor: BrushController,\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n    return this;\n  },\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n    this._zr.add(thisGroup);\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n    this._zr.remove(this.group);\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n  return creatingCover;\n}\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n  if (!track.length) {\n    return false;\n  }\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]],\n  // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n  currPanel && zr.setCursorStyle('crosshair');\n}\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n  controller._track.push(localCursorPoint.slice());\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n      controller._covers.push(creatingCover);\n    }\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n  return eventParams;\n}\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n  return brushType;\n}\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var lastPoint = this._lastMouseMovePoint;\n    lastPoint.x = e.offsetX;\n    lastPoint.y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(lastPoint.x, lastPoint.y);\n    resetCursor(this, e, localCursorPoint);\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  },\n  globalout: function (e) {\n    handleDragEnd(this, e, true);\n  }\n};\nfunction handleDragEnd(controller, e, isGlobalOut) {\n  if (controller._dragging) {\n    // Just be worried about bring some side effect to the world\n    // out of echarts, we do not `preventDefault` for globalout.\n    !isGlobalOut && preventDefault(e);\n    var pointerX = e.offsetX;\n    var pointerY = e.offsetY;\n    var lastPoint = controller._lastMouseMovePoint;\n    if (isGlobalOut) {\n      pointerX = lastPoint.x;\n      pointerY = lastPoint.y;\n    }\n    var localCursorPoint = controller.group.transformCoordToLocal(pointerX, pointerY); // FIXME\n    // Here `e` is used only in `onIrrelevantElement` finally. And it's OK\n    // that pass the `e` of `globalout` to `onIrrelevantElement`. But it is\n    // not a good design of these interfaces. However, we do not refactor\n    // these code now because the implementation of `onIrrelevantElement`\n    // need to be discussed and probably be changed in future, becuase it\n    // slows down the performance of zrender in some cases.\n\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\nvar _default = BrushController;\nmodule.exports = _default;","map":{"version":3,"names":["_config","require","__DEV__","zrUtil","Eventful","graphic","interactionMutex","DataDiffer","curry","each","map","mathMin","Math","min","mathMax","max","mathPow","pow","COVER_Z","UNSELECT_THRESHOLD","MIN_RESIZE_LINE_WIDTH","MUTEX_RESOURCE_KEY","DIRECTION_MAP","w","e","n","s","CURSOR_MAP","ne","sw","nw","se","DEFAULT_BRUSH_OPT","brushStyle","lineWidth","stroke","fill","transformable","brushMode","removeOnClick","baseUID","BrushController","zr","call","_zr","group","Group","_brushType","_brushOption","_panels","_track","_dragging","_lastMouseMovePoint","_covers","_creatingCover","_creatingPanel","_enableGlobalPan","_uid","_handlers","mouseHandlers","handler","eventName","bind","prototype","constructor","enableBrush","brushOption","doDisableBrush","brushType","doEnableBrush","setPanels","panelOpts","length","panels","panelId","clone","mount","opt","enableGlobalPan","thisGroup","add","attr","position","rotation","scale","_transform","getLocalTransform","eachCover","cb","context","updateCovers","brushOptionList","merge","tmpIdPrefix","oldCovers","newCovers","controller","creatingCover","oldGetKey","getKey","addOrUpdate","update","remove","execute","index","id","cover","__brushOption","newIndex","oldIndex","newBrushOption","endCreating","createCover","updateCoverAfterCreation","unmount","clearCovers","dispose","off","mixin","take","on","release","coverRenderers","updateZ","coverRenderer","getCoverRenderer","updateCoverShape","range","z","traverse","el","z2","updateCommon","getPanelByPoint","localCursorPoint","panel","transform","pn","isTargetByCursor","getPanelByCover","covers","originalLength","trigger","areas","isEnd","shouldShowCover","track","p2","p1","dx","dy","dist","getTrackEnds","tail","createBaseRectCover","doDrift","edgeNames","Rect","name","style","makeStyle","silent","draggable","cursor","drift","ondragend","opacity","invisible","updateBaseRect","localRange","handleSize","x","y","xa","ya","x2","y2","x2a","y2a","width","height","widtha","heighta","updateRectShape","mainEl","childAt","useStyle","childOfName","globalDir","getGlobalDirection","h","setShape","pointsToRect","clipByPanel","defaults","strokeNoScale","formatRectRange","getTransform","localDirection","split","reverse","join","inverseMap","left","right","top","bottom","transformDirection","driftRect","toRectRange","fromRectRange","rectRange","localDelta","toLocalDelta","namePart","ind","driftPolygon","point","localD","transformCoordToLocal","localZero","data","clipPath","points","xmin","ymin","xmax","ymax","resetCursor","currPanel","i","contain","setCursorStyle","preventDefault","rawE","event","mainShapeContain","updateCoverByMouse","thisBrushOption","eventParams","push","slice","determineBrushType","coverBrushOption","getCreatingRange","defaultBrushType","mousedown","handleDragEnd","target","offsetX","offsetY","mousemove","lastPoint","mouseup","globalout","isGlobalOut","pointerX","pointerY","lineX","getLineRenderer","lineY","rect","localTrack","ends","polygon","Polyline","Polygon","xyIndex","otherExtent","getLinearBrushOtherExtent","getWidth","getHeight","_default","module","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/component/helper/BrushController.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar _config = require(\"../../config\");\n\nvar __DEV__ = _config.__DEV__;\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar Eventful = require(\"zrender/lib/mixin/Eventful\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar interactionMutex = require(\"./interactionMutex\");\n\nvar DataDiffer = require(\"../../data/DataDiffer\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar curry = zrUtil.curry;\nvar each = zrUtil.each;\nvar map = zrUtil.map;\nvar mathMin = Math.min;\nvar mathMax = Math.max;\nvar mathPow = Math.pow;\nvar COVER_Z = 10000;\nvar UNSELECT_THRESHOLD = 6;\nvar MIN_RESIZE_LINE_WIDTH = 6;\nvar MUTEX_RESOURCE_KEY = 'globalPan';\nvar DIRECTION_MAP = {\n  w: [0, 0],\n  e: [0, 1],\n  n: [1, 0],\n  s: [1, 1]\n};\nvar CURSOR_MAP = {\n  w: 'ew',\n  e: 'ew',\n  n: 'ns',\n  s: 'ns',\n  ne: 'nesw',\n  sw: 'nesw',\n  nw: 'nwse',\n  se: 'nwse'\n};\nvar DEFAULT_BRUSH_OPT = {\n  brushStyle: {\n    lineWidth: 2,\n    stroke: 'rgba(0,0,0,0.3)',\n    fill: 'rgba(0,0,0,0.1)'\n  },\n  transformable: true,\n  brushMode: 'single',\n  removeOnClick: false\n};\nvar baseUID = 0;\n/**\n * @alias module:echarts/component/helper/BrushController\n * @constructor\n * @mixin {module:zrender/mixin/Eventful}\n * @event module:echarts/component/helper/BrushController#brush\n *        params:\n *            areas: Array.<Array>, coord relates to container group,\n *                                    If no container specified, to global.\n *            opt {\n *                isEnd: boolean,\n *                removeOnClick: boolean\n *            }\n *\n * @param {module:zrender/zrender~ZRender} zr\n */\n\nfunction BrushController(zr) {\n  Eventful.call(this);\n  /**\n   * @type {module:zrender/zrender~ZRender}\n   * @private\n   */\n\n  this._zr = zr;\n  /**\n   * @type {module:zrender/container/Group}\n   * @readOnly\n   */\n\n  this.group = new graphic.Group();\n  /**\n   * Only for drawing (after enabledBrush).\n   *     'line', 'rect', 'polygon' or false\n   *     If passing false/null/undefined, disable brush.\n   *     If passing 'auto', determined by panel.defaultBrushType\n   * @private\n   * @type {string}\n   */\n\n  this._brushType;\n  /**\n   * Only for drawing (after enabledBrush).\n   *\n   * @private\n   * @type {Object}\n   */\n\n  this._brushOption;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._panels;\n  /**\n   * @private\n   * @type {Array.<nubmer>}\n   */\n\n  this._track = [];\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._dragging;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._lastMouseMovePoint = {};\n  /**\n   * @private\n   * @type {Array}\n   */\n\n  this._covers = [];\n  /**\n   * @private\n   * @type {moudule:zrender/container/Group}\n   */\n\n  this._creatingCover;\n  /**\n   * `true` means global panel\n   * @private\n   * @type {module:zrender/container/Group|boolean}\n   */\n\n  this._creatingPanel;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  this._enableGlobalPan;\n  /**\n   * @private\n   * @type {boolean}\n   */\n\n  /**\n   * @private\n   * @type {string}\n   */\n  this._uid = 'brushController_' + baseUID++;\n  /**\n   * @private\n   * @type {Object}\n   */\n\n  this._handlers = {};\n  each(mouseHandlers, function (handler, eventName) {\n    this._handlers[eventName] = zrUtil.bind(handler, this);\n  }, this);\n}\n\nBrushController.prototype = {\n  constructor: BrushController,\n\n  /**\n   * If set to null/undefined/false, select disabled.\n   * @param {Object} brushOption\n   * @param {string|boolean} brushOption.brushType 'line', 'rect', 'polygon' or false\n   *                          If passing false/null/undefined, disable brush.\n   *                          If passing 'auto', determined by panel.defaultBrushType.\n   *                              ('auto' can not be used in global panel)\n   * @param {number} [brushOption.brushMode='single'] 'single' or 'multiple'\n   * @param {boolean} [brushOption.transformable=true]\n   * @param {boolean} [brushOption.removeOnClick=false]\n   * @param {Object} [brushOption.brushStyle]\n   * @param {number} [brushOption.brushStyle.width]\n   * @param {number} [brushOption.brushStyle.lineWidth]\n   * @param {string} [brushOption.brushStyle.stroke]\n   * @param {string} [brushOption.brushStyle.fill]\n   * @param {number} [brushOption.z]\n   */\n  enableBrush: function (brushOption) {\n    this._brushType && doDisableBrush(this);\n    brushOption.brushType && doEnableBrush(this, brushOption);\n    return this;\n  },\n\n  /**\n   * @param {Array.<Object>} panelOpts If not pass, it is global brush.\n   *        Each items: {\n   *            panelId, // mandatory.\n   *            clipPath, // mandatory. function.\n   *            isTargetByCursor, // mandatory. function.\n   *            defaultBrushType, // optional, only used when brushType is 'auto'.\n   *            getLinearBrushOtherExtent, // optional. function.\n   *        }\n   */\n  setPanels: function (panelOpts) {\n    if (panelOpts && panelOpts.length) {\n      var panels = this._panels = {};\n      zrUtil.each(panelOpts, function (panelOpts) {\n        panels[panelOpts.panelId] = zrUtil.clone(panelOpts);\n      });\n    } else {\n      this._panels = null;\n    }\n\n    return this;\n  },\n\n  /**\n   * @param {Object} [opt]\n   * @return {boolean} [opt.enableGlobalPan=false]\n   */\n  mount: function (opt) {\n    opt = opt || {};\n    this._enableGlobalPan = opt.enableGlobalPan;\n    var thisGroup = this.group;\n\n    this._zr.add(thisGroup);\n\n    thisGroup.attr({\n      position: opt.position || [0, 0],\n      rotation: opt.rotation || 0,\n      scale: opt.scale || [1, 1]\n    });\n    this._transform = thisGroup.getLocalTransform();\n    return this;\n  },\n  eachCover: function (cb, context) {\n    each(this._covers, cb, context);\n  },\n\n  /**\n   * Update covers.\n   * @param {Array.<Object>} brushOptionList Like:\n   *        [\n   *            {id: 'xx', brushType: 'line', range: [23, 44], brushStyle, transformable},\n   *            {id: 'yy', brushType: 'rect', range: [[23, 44], [23, 54]]},\n   *            ...\n   *        ]\n   *        `brushType` is required in each cover info. (can not be 'auto')\n   *        `id` is not mandatory.\n   *        `brushStyle`, `transformable` is not mandatory, use DEFAULT_BRUSH_OPT by default.\n   *        If brushOptionList is null/undefined, all covers removed.\n   */\n  updateCovers: function (brushOptionList) {\n    brushOptionList = zrUtil.map(brushOptionList, function (brushOption) {\n      return zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n    });\n    var tmpIdPrefix = '\\0-brush-index-';\n    var oldCovers = this._covers;\n    var newCovers = this._covers = [];\n    var controller = this;\n    var creatingCover = this._creatingCover;\n    new DataDiffer(oldCovers, brushOptionList, oldGetKey, getKey).add(addOrUpdate).update(addOrUpdate).remove(remove).execute();\n    return this;\n\n    function getKey(brushOption, index) {\n      return (brushOption.id != null ? brushOption.id : tmpIdPrefix + index) + '-' + brushOption.brushType;\n    }\n\n    function oldGetKey(cover, index) {\n      return getKey(cover.__brushOption, index);\n    }\n\n    function addOrUpdate(newIndex, oldIndex) {\n      var newBrushOption = brushOptionList[newIndex]; // Consider setOption in event listener of brushSelect,\n      // where updating cover when creating should be forbiden.\n\n      if (oldIndex != null && oldCovers[oldIndex] === creatingCover) {\n        newCovers[newIndex] = oldCovers[oldIndex];\n      } else {\n        var cover = newCovers[newIndex] = oldIndex != null ? (oldCovers[oldIndex].__brushOption = newBrushOption, oldCovers[oldIndex]) : endCreating(controller, createCover(controller, newBrushOption));\n        updateCoverAfterCreation(controller, cover);\n      }\n    }\n\n    function remove(oldIndex) {\n      if (oldCovers[oldIndex] !== creatingCover) {\n        controller.group.remove(oldCovers[oldIndex]);\n      }\n    }\n  },\n  unmount: function () {\n    this.enableBrush(false); // container may 'removeAll' outside.\n\n    clearCovers(this);\n\n    this._zr.remove(this.group);\n\n    return this;\n  },\n  dispose: function () {\n    this.unmount();\n    this.off();\n  }\n};\nzrUtil.mixin(BrushController, Eventful);\n\nfunction doEnableBrush(controller, brushOption) {\n  var zr = controller._zr; // Consider roam, which takes globalPan too.\n\n  if (!controller._enableGlobalPan) {\n    interactionMutex.take(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  }\n\n  each(controller._handlers, function (handler, eventName) {\n    zr.on(eventName, handler);\n  });\n  controller._brushType = brushOption.brushType;\n  controller._brushOption = zrUtil.merge(zrUtil.clone(DEFAULT_BRUSH_OPT), brushOption, true);\n}\n\nfunction doDisableBrush(controller) {\n  var zr = controller._zr;\n  interactionMutex.release(zr, MUTEX_RESOURCE_KEY, controller._uid);\n  each(controller._handlers, function (handler, eventName) {\n    zr.off(eventName, handler);\n  });\n  controller._brushType = controller._brushOption = null;\n}\n\nfunction createCover(controller, brushOption) {\n  var cover = coverRenderers[brushOption.brushType].createCover(controller, brushOption);\n  cover.__brushOption = brushOption;\n  updateZ(cover, brushOption);\n  controller.group.add(cover);\n  return cover;\n}\n\nfunction endCreating(controller, creatingCover) {\n  var coverRenderer = getCoverRenderer(creatingCover);\n\n  if (coverRenderer.endCreating) {\n    coverRenderer.endCreating(controller, creatingCover);\n    updateZ(creatingCover, creatingCover.__brushOption);\n  }\n\n  return creatingCover;\n}\n\nfunction updateCoverShape(controller, cover) {\n  var brushOption = cover.__brushOption;\n  getCoverRenderer(cover).updateCoverShape(controller, cover, brushOption.range, brushOption);\n}\n\nfunction updateZ(cover, brushOption) {\n  var z = brushOption.z;\n  z == null && (z = COVER_Z);\n  cover.traverse(function (el) {\n    el.z = z;\n    el.z2 = z; // Consider in given container.\n  });\n}\n\nfunction updateCoverAfterCreation(controller, cover) {\n  getCoverRenderer(cover).updateCommon(controller, cover);\n  updateCoverShape(controller, cover);\n}\n\nfunction getCoverRenderer(cover) {\n  return coverRenderers[cover.__brushOption.brushType];\n} // return target panel or `true` (means global panel)\n\n\nfunction getPanelByPoint(controller, e, localCursorPoint) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panel;\n  var transform = controller._transform;\n  each(panels, function (pn) {\n    pn.isTargetByCursor(e, localCursorPoint, transform) && (panel = pn);\n  });\n  return panel;\n} // Return a panel or true\n\n\nfunction getPanelByCover(controller, cover) {\n  var panels = controller._panels;\n\n  if (!panels) {\n    return true; // Global panel\n  }\n\n  var panelId = cover.__brushOption.panelId; // User may give cover without coord sys info,\n  // which is then treated as global panel.\n\n  return panelId != null ? panels[panelId] : true;\n}\n\nfunction clearCovers(controller) {\n  var covers = controller._covers;\n  var originalLength = covers.length;\n  each(covers, function (cover) {\n    controller.group.remove(cover);\n  }, controller);\n  covers.length = 0;\n  return !!originalLength;\n}\n\nfunction trigger(controller, opt) {\n  var areas = map(controller._covers, function (cover) {\n    var brushOption = cover.__brushOption;\n    var range = zrUtil.clone(brushOption.range);\n    return {\n      brushType: brushOption.brushType,\n      panelId: brushOption.panelId,\n      range: range\n    };\n  });\n  controller.trigger('brush', areas, {\n    isEnd: !!opt.isEnd,\n    removeOnClick: !!opt.removeOnClick\n  });\n}\n\nfunction shouldShowCover(controller) {\n  var track = controller._track;\n\n  if (!track.length) {\n    return false;\n  }\n\n  var p2 = track[track.length - 1];\n  var p1 = track[0];\n  var dx = p2[0] - p1[0];\n  var dy = p2[1] - p1[1];\n  var dist = mathPow(dx * dx + dy * dy, 0.5);\n  return dist > UNSELECT_THRESHOLD;\n}\n\nfunction getTrackEnds(track) {\n  var tail = track.length - 1;\n  tail < 0 && (tail = 0);\n  return [track[0], track[tail]];\n}\n\nfunction createBaseRectCover(doDrift, controller, brushOption, edgeNames) {\n  var cover = new graphic.Group();\n  cover.add(new graphic.Rect({\n    name: 'main',\n    style: makeStyle(brushOption),\n    silent: true,\n    draggable: true,\n    cursor: 'move',\n    drift: curry(doDrift, controller, cover, 'nswe'),\n    ondragend: curry(trigger, controller, {\n      isEnd: true\n    })\n  }));\n  each(edgeNames, function (name) {\n    cover.add(new graphic.Rect({\n      name: name,\n      style: {\n        opacity: 0\n      },\n      draggable: true,\n      silent: true,\n      invisible: true,\n      drift: curry(doDrift, controller, cover, name),\n      ondragend: curry(trigger, controller, {\n        isEnd: true\n      })\n    }));\n  });\n  return cover;\n}\n\nfunction updateBaseRect(controller, cover, localRange, brushOption) {\n  var lineWidth = brushOption.brushStyle.lineWidth || 0;\n  var handleSize = mathMax(lineWidth, MIN_RESIZE_LINE_WIDTH);\n  var x = localRange[0][0];\n  var y = localRange[1][0];\n  var xa = x - lineWidth / 2;\n  var ya = y - lineWidth / 2;\n  var x2 = localRange[0][1];\n  var y2 = localRange[1][1];\n  var x2a = x2 - handleSize + lineWidth / 2;\n  var y2a = y2 - handleSize + lineWidth / 2;\n  var width = x2 - x;\n  var height = y2 - y;\n  var widtha = width + lineWidth;\n  var heighta = height + lineWidth;\n  updateRectShape(controller, cover, 'main', x, y, width, height);\n\n  if (brushOption.transformable) {\n    updateRectShape(controller, cover, 'w', xa, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'e', x2a, ya, handleSize, heighta);\n    updateRectShape(controller, cover, 'n', xa, ya, widtha, handleSize);\n    updateRectShape(controller, cover, 's', xa, y2a, widtha, handleSize);\n    updateRectShape(controller, cover, 'nw', xa, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'ne', x2a, ya, handleSize, handleSize);\n    updateRectShape(controller, cover, 'sw', xa, y2a, handleSize, handleSize);\n    updateRectShape(controller, cover, 'se', x2a, y2a, handleSize, handleSize);\n  }\n}\n\nfunction updateCommon(controller, cover) {\n  var brushOption = cover.__brushOption;\n  var transformable = brushOption.transformable;\n  var mainEl = cover.childAt(0);\n  mainEl.useStyle(makeStyle(brushOption));\n  mainEl.attr({\n    silent: !transformable,\n    cursor: transformable ? 'move' : 'default'\n  });\n  each(['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw'], function (name) {\n    var el = cover.childOfName(name);\n    var globalDir = getGlobalDirection(controller, name);\n    el && el.attr({\n      silent: !transformable,\n      invisible: !transformable,\n      cursor: transformable ? CURSOR_MAP[globalDir] + '-resize' : null\n    });\n  });\n}\n\nfunction updateRectShape(controller, cover, name, x, y, w, h) {\n  var el = cover.childOfName(name);\n  el && el.setShape(pointsToRect(clipByPanel(controller, cover, [[x, y], [x + w, y + h]])));\n}\n\nfunction makeStyle(brushOption) {\n  return zrUtil.defaults({\n    strokeNoScale: true\n  }, brushOption.brushStyle);\n}\n\nfunction formatRectRange(x, y, x2, y2) {\n  var min = [mathMin(x, x2), mathMin(y, y2)];\n  var max = [mathMax(x, x2), mathMax(y, y2)];\n  return [[min[0], max[0]], // x range\n  [min[1], max[1]] // y range\n  ];\n}\n\nfunction getTransform(controller) {\n  return graphic.getTransform(controller.group);\n}\n\nfunction getGlobalDirection(controller, localDirection) {\n  if (localDirection.length > 1) {\n    localDirection = localDirection.split('');\n    var globalDir = [getGlobalDirection(controller, localDirection[0]), getGlobalDirection(controller, localDirection[1])];\n    (globalDir[0] === 'e' || globalDir[0] === 'w') && globalDir.reverse();\n    return globalDir.join('');\n  } else {\n    var map = {\n      w: 'left',\n      e: 'right',\n      n: 'top',\n      s: 'bottom'\n    };\n    var inverseMap = {\n      left: 'w',\n      right: 'e',\n      top: 'n',\n      bottom: 's'\n    };\n    var globalDir = graphic.transformDirection(map[localDirection], getTransform(controller));\n    return inverseMap[globalDir];\n  }\n}\n\nfunction driftRect(toRectRange, fromRectRange, controller, cover, name, dx, dy, e) {\n  var brushOption = cover.__brushOption;\n  var rectRange = toRectRange(brushOption.range);\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(name.split(''), function (namePart) {\n    var ind = DIRECTION_MAP[namePart];\n    rectRange[ind[0]][ind[1]] += localDelta[ind[0]];\n  });\n  brushOption.range = fromRectRange(formatRectRange(rectRange[0][0], rectRange[1][0], rectRange[0][1], rectRange[1][1]));\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction driftPolygon(controller, cover, dx, dy, e) {\n  var range = cover.__brushOption.range;\n  var localDelta = toLocalDelta(controller, dx, dy);\n  each(range, function (point) {\n    point[0] += localDelta[0];\n    point[1] += localDelta[1];\n  });\n  updateCoverAfterCreation(controller, cover);\n  trigger(controller, {\n    isEnd: false\n  });\n}\n\nfunction toLocalDelta(controller, dx, dy) {\n  var thisGroup = controller.group;\n  var localD = thisGroup.transformCoordToLocal(dx, dy);\n  var localZero = thisGroup.transformCoordToLocal(0, 0);\n  return [localD[0] - localZero[0], localD[1] - localZero[1]];\n}\n\nfunction clipByPanel(controller, cover, data) {\n  var panel = getPanelByCover(controller, cover);\n  return panel && panel !== true ? panel.clipPath(data, controller._transform) : zrUtil.clone(data);\n}\n\nfunction pointsToRect(points) {\n  var xmin = mathMin(points[0][0], points[1][0]);\n  var ymin = mathMin(points[0][1], points[1][1]);\n  var xmax = mathMax(points[0][0], points[1][0]);\n  var ymax = mathMax(points[0][1], points[1][1]);\n  return {\n    x: xmin,\n    y: ymin,\n    width: xmax - xmin,\n    height: ymax - ymin\n  };\n}\n\nfunction resetCursor(controller, e, localCursorPoint) {\n  // Check active\n  if (!controller._brushType) {\n    return;\n  }\n\n  var zr = controller._zr;\n  var covers = controller._covers;\n  var currPanel = getPanelByPoint(controller, e, localCursorPoint); // Check whether in covers.\n\n  if (!controller._dragging) {\n    for (var i = 0; i < covers.length; i++) {\n      var brushOption = covers[i].__brushOption;\n\n      if (currPanel && (currPanel === true || brushOption.panelId === currPanel.panelId) && coverRenderers[brushOption.brushType].contain(covers[i], localCursorPoint[0], localCursorPoint[1])) {\n        // Use cursor style set on cover.\n        return;\n      }\n    }\n  }\n\n  currPanel && zr.setCursorStyle('crosshair');\n}\n\nfunction preventDefault(e) {\n  var rawE = e.event;\n  rawE.preventDefault && rawE.preventDefault();\n}\n\nfunction mainShapeContain(cover, x, y) {\n  return cover.childOfName('main').contain(x, y);\n}\n\nfunction updateCoverByMouse(controller, e, localCursorPoint, isEnd) {\n  var creatingCover = controller._creatingCover;\n  var panel = controller._creatingPanel;\n  var thisBrushOption = controller._brushOption;\n  var eventParams;\n\n  controller._track.push(localCursorPoint.slice());\n\n  if (shouldShowCover(controller) || creatingCover) {\n    if (panel && !creatingCover) {\n      thisBrushOption.brushMode === 'single' && clearCovers(controller);\n      var brushOption = zrUtil.clone(thisBrushOption);\n      brushOption.brushType = determineBrushType(brushOption.brushType, panel);\n      brushOption.panelId = panel === true ? null : panel.panelId;\n      creatingCover = controller._creatingCover = createCover(controller, brushOption);\n\n      controller._covers.push(creatingCover);\n    }\n\n    if (creatingCover) {\n      var coverRenderer = coverRenderers[determineBrushType(controller._brushType, panel)];\n      var coverBrushOption = creatingCover.__brushOption;\n      coverBrushOption.range = coverRenderer.getCreatingRange(clipByPanel(controller, creatingCover, controller._track));\n\n      if (isEnd) {\n        endCreating(controller, creatingCover);\n        coverRenderer.updateCommon(controller, creatingCover);\n      }\n\n      updateCoverShape(controller, creatingCover);\n      eventParams = {\n        isEnd: isEnd\n      };\n    }\n  } else if (isEnd && thisBrushOption.brushMode === 'single' && thisBrushOption.removeOnClick) {\n    // Help user to remove covers easily, only by a tiny drag, in 'single' mode.\n    // But a single click do not clear covers, because user may have casual\n    // clicks (for example, click on other component and do not expect covers\n    // disappear).\n    // Only some cover removed, trigger action, but not every click trigger action.\n    if (getPanelByPoint(controller, e, localCursorPoint) && clearCovers(controller)) {\n      eventParams = {\n        isEnd: isEnd,\n        removeOnClick: true\n      };\n    }\n  }\n\n  return eventParams;\n}\n\nfunction determineBrushType(brushType, panel) {\n  if (brushType === 'auto') {\n    return panel.defaultBrushType;\n  }\n\n  return brushType;\n}\n\nvar mouseHandlers = {\n  mousedown: function (e) {\n    if (this._dragging) {\n      // In case some browser do not support globalOut,\n      // and release mose out side the browser.\n      handleDragEnd(this, e);\n    } else if (!e.target || !e.target.draggable) {\n      preventDefault(e);\n      var localCursorPoint = this.group.transformCoordToLocal(e.offsetX, e.offsetY);\n      this._creatingCover = null;\n      var panel = this._creatingPanel = getPanelByPoint(this, e, localCursorPoint);\n\n      if (panel) {\n        this._dragging = true;\n        this._track = [localCursorPoint.slice()];\n      }\n    }\n  },\n  mousemove: function (e) {\n    var lastPoint = this._lastMouseMovePoint;\n    lastPoint.x = e.offsetX;\n    lastPoint.y = e.offsetY;\n    var localCursorPoint = this.group.transformCoordToLocal(lastPoint.x, lastPoint.y);\n    resetCursor(this, e, localCursorPoint);\n\n    if (this._dragging) {\n      preventDefault(e);\n      var eventParams = updateCoverByMouse(this, e, localCursorPoint, false);\n      eventParams && trigger(this, eventParams);\n    }\n  },\n  mouseup: function (e) {\n    handleDragEnd(this, e);\n  },\n  globalout: function (e) {\n    handleDragEnd(this, e, true);\n  }\n};\n\nfunction handleDragEnd(controller, e, isGlobalOut) {\n  if (controller._dragging) {\n    // Just be worried about bring some side effect to the world\n    // out of echarts, we do not `preventDefault` for globalout.\n    !isGlobalOut && preventDefault(e);\n    var pointerX = e.offsetX;\n    var pointerY = e.offsetY;\n    var lastPoint = controller._lastMouseMovePoint;\n\n    if (isGlobalOut) {\n      pointerX = lastPoint.x;\n      pointerY = lastPoint.y;\n    }\n\n    var localCursorPoint = controller.group.transformCoordToLocal(pointerX, pointerY); // FIXME\n    // Here `e` is used only in `onIrrelevantElement` finally. And it's OK\n    // that pass the `e` of `globalout` to `onIrrelevantElement`. But it is\n    // not a good design of these interfaces. However, we do not refactor\n    // these code now because the implementation of `onIrrelevantElement`\n    // need to be discussed and probably be changed in future, becuase it\n    // slows down the performance of zrender in some cases.\n\n    var eventParams = updateCoverByMouse(controller, e, localCursorPoint, true);\n    controller._dragging = false;\n    controller._track = [];\n    controller._creatingCover = null; // trigger event shoule be at final, after procedure will be nested.\n\n    eventParams && trigger(controller, eventParams);\n  }\n}\n/**\n * key: brushType\n * @type {Object}\n */\n\n\nvar coverRenderers = {\n  lineX: getLineRenderer(0),\n  lineY: getLineRenderer(1),\n  rect: {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        return range;\n      }, function (range) {\n        return range;\n      }), controller, brushOption, ['w', 'e', 'n', 's', 'se', 'sw', 'ne', 'nw']);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      return formatRectRange(ends[1][0], ends[1][1], ends[0][0], ends[0][1]);\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      updateBaseRect(controller, cover, localRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  },\n  polygon: {\n    createCover: function (controller, brushOption) {\n      var cover = new graphic.Group(); // Do not use graphic.Polygon because graphic.Polyline do not close the\n      // border of the shape when drawing, which is a better experience for user.\n\n      cover.add(new graphic.Polyline({\n        name: 'main',\n        style: makeStyle(brushOption),\n        silent: true\n      }));\n      return cover;\n    },\n    getCreatingRange: function (localTrack) {\n      return localTrack;\n    },\n    endCreating: function (controller, cover) {\n      cover.remove(cover.childAt(0)); // Use graphic.Polygon close the shape.\n\n      cover.add(new graphic.Polygon({\n        name: 'main',\n        draggable: true,\n        drift: curry(driftPolygon, controller, cover),\n        ondragend: curry(trigger, controller, {\n          isEnd: true\n        })\n      }));\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      cover.childAt(0).setShape({\n        points: clipByPanel(controller, cover, localRange)\n      });\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  }\n};\n\nfunction getLineRenderer(xyIndex) {\n  return {\n    createCover: function (controller, brushOption) {\n      return createBaseRectCover(curry(driftRect, function (range) {\n        var rectRange = [range, [0, 100]];\n        xyIndex && rectRange.reverse();\n        return rectRange;\n      }, function (rectRange) {\n        return rectRange[xyIndex];\n      }), controller, brushOption, [['w', 'e'], ['n', 's']][xyIndex]);\n    },\n    getCreatingRange: function (localTrack) {\n      var ends = getTrackEnds(localTrack);\n      var min = mathMin(ends[0][xyIndex], ends[1][xyIndex]);\n      var max = mathMax(ends[0][xyIndex], ends[1][xyIndex]);\n      return [min, max];\n    },\n    updateCoverShape: function (controller, cover, localRange, brushOption) {\n      var otherExtent; // If brushWidth not specified, fit the panel.\n\n      var panel = getPanelByCover(controller, cover);\n\n      if (panel !== true && panel.getLinearBrushOtherExtent) {\n        otherExtent = panel.getLinearBrushOtherExtent(xyIndex, controller._transform);\n      } else {\n        var zr = controller._zr;\n        otherExtent = [0, [zr.getWidth(), zr.getHeight()][1 - xyIndex]];\n      }\n\n      var rectRange = [localRange, otherExtent];\n      xyIndex && rectRange.reverse();\n      updateBaseRect(controller, cover, rectRange, brushOption);\n    },\n    updateCommon: updateCommon,\n    contain: mainShapeContain\n  };\n}\n\nvar _default = BrushController;\nmodule.exports = _default;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}