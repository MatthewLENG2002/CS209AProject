{"ast":null,"code":"/**\n * Sub-pixel optimize for canvas rendering, prevent from blur\n * when rendering a thin vertical/horizontal line.\n */\nvar round = Math.round;\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x1]\n * @param {number} [inputShape.y1]\n * @param {number} [inputShape.x2]\n * @param {number} [inputShape.y2]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n  if (round(x1 * 2) === round(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  } else {\n    outputShape.x1 = x1;\n    outputShape.x2 = x2;\n  }\n  if (round(y1 * 2) === round(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  } else {\n    outputShape.y1 = y1;\n    outputShape.y2 = y2;\n  }\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x]\n * @param {number} [inputShape.y]\n * @param {number} [inputShape.width]\n * @param {number} [inputShape.height]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;","map":{"version":3,"names":["round","Math","subPixelOptimizeLine","outputShape","inputShape","style","lineWidth","x1","x2","y1","y2","subPixelOptimize","subPixelOptimizeRect","originX","x","originY","y","originWidth","width","originHeight","height","max","position","positiveOrNegative","doubledPosition","exports"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/zrender/lib/graphic/helper/subPixelOptimize.js"],"sourcesContent":["/**\n * Sub-pixel optimize for canvas rendering, prevent from blur\n * when rendering a thin vertical/horizontal line.\n */\nvar round = Math.round;\n/**\n * Sub pixel optimize line for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x1`, `x2`, `y1`, `y2` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x1]\n * @param {number} [inputShape.y1]\n * @param {number} [inputShape.x2]\n * @param {number} [inputShape.y2]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\nfunction subPixelOptimizeLine(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var x1 = inputShape.x1;\n  var x2 = inputShape.x2;\n  var y1 = inputShape.y1;\n  var y2 = inputShape.y2;\n\n  if (round(x1 * 2) === round(x2 * 2)) {\n    outputShape.x1 = outputShape.x2 = subPixelOptimize(x1, lineWidth, true);\n  } else {\n    outputShape.x1 = x1;\n    outputShape.x2 = x2;\n  }\n\n  if (round(y1 * 2) === round(y2 * 2)) {\n    outputShape.y1 = outputShape.y2 = subPixelOptimize(y1, lineWidth, true);\n  } else {\n    outputShape.y1 = y1;\n    outputShape.y2 = y2;\n  }\n}\n/**\n * Sub pixel optimize rect for canvas\n *\n * @param {Object} outputShape The modification will be performed on `outputShape`.\n *                 `outputShape` and `inputShape` can be the same object.\n *                 `outputShape` object can be used repeatly, because all of\n *                 the `x`, `y`, `width`, `height` will be assigned in this method.\n * @param {Object} [inputShape]\n * @param {number} [inputShape.x]\n * @param {number} [inputShape.y]\n * @param {number} [inputShape.width]\n * @param {number} [inputShape.height]\n * @param {Object} [style]\n * @param {number} [style.lineWidth]\n */\n\n\nfunction subPixelOptimizeRect(outputShape, inputShape, style) {\n  var lineWidth = style && style.lineWidth;\n\n  if (!inputShape || !lineWidth) {\n    return;\n  }\n\n  var originX = inputShape.x;\n  var originY = inputShape.y;\n  var originWidth = inputShape.width;\n  var originHeight = inputShape.height;\n  outputShape.x = subPixelOptimize(originX, lineWidth, true);\n  outputShape.y = subPixelOptimize(originY, lineWidth, true);\n  outputShape.width = Math.max(subPixelOptimize(originX + originWidth, lineWidth, false) - outputShape.x, originWidth === 0 ? 0 : 1);\n  outputShape.height = Math.max(subPixelOptimize(originY + originHeight, lineWidth, false) - outputShape.y, originHeight === 0 ? 0 : 1);\n}\n/**\n * Sub pixel optimize for canvas\n *\n * @param {number} position Coordinate, such as x, y\n * @param {number} lineWidth Should be nonnegative integer.\n * @param {boolean=} positiveOrNegative Default false (negative).\n * @return {number} Optimized position.\n */\n\n\nfunction subPixelOptimize(position, lineWidth, positiveOrNegative) {\n  // Assure that (position + lineWidth / 2) is near integer edge,\n  // otherwise line will be fuzzy in canvas.\n  var doubledPosition = round(position * 2);\n  return (doubledPosition + round(lineWidth)) % 2 === 0 ? doubledPosition / 2 : (doubledPosition + (positiveOrNegative ? 1 : -1)) / 2;\n}\n\nexports.subPixelOptimizeLine = subPixelOptimizeLine;\nexports.subPixelOptimizeRect = subPixelOptimizeRect;\nexports.subPixelOptimize = subPixelOptimize;"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}