{"ast":null,"code":"/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\nvar graphic = require(\"../../util/graphic\");\nvar AxisBuilder = require(\"./AxisBuilder\");\nvar AxisView = require(\"./AxisView\");\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n    if (!axisModel.get('show')) {\n      return;\n    }\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n    this._axisGroup.add(axisBuilder.getGroup());\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n    if (axis.scale.isBlank()) {\n      return;\n    }\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n      this._axisGroup.add(new graphic.Line({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        subPixelOptimize: true,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      }));\n    }\n  },\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n    if (axis.scale.isBlank()) {\n      return;\n    }\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});","map":{"version":3,"names":["zrUtil","require","graphic","AxisBuilder","AxisView","cartesianAxisHelper","axisBuilderAttrs","selfBuilderAttrs","CartesianAxisView","extend","type","axisPointerClass","render","axisModel","ecModel","api","payload","group","removeAll","oldAxisGroup","_axisGroup","Group","add","get","gridModel","getCoordSysModel","layout","axisBuilder","each","getGroup","name","groupTransition","superCall","remove","_splitAreaColors","_splitLine","axis","scale","isBlank","splitLineModel","getModel","lineStyleModel","lineColors","isArray","gridRect","coordinateSystem","getRect","isHorizontal","lineCount","ticksCoords","getTicksCoords","tickModel","p1","p2","lineStyle","getLineStyle","i","length","tickCoord","toGlobalCoord","coord","y","height","x","width","colorIndex","tickValue","Line","anid","subPixelOptimize","shape","x1","y1","x2","y2","style","defaults","stroke","silent","_splitArea","splitAreaModel","areaStyleModel","areaColors","clamp","areaColorsLen","lastSplitAreaColors","newSplitAreaColors","createHashMap","cIndex","prev","areaStyle","getAreaStyle","set","Rect","fill"],"sources":["/Users/tangxinyu/WebstormProjects/cs209a_proj/node_modules/echarts/lib/component/axis/CartesianAxisView.js"],"sourcesContent":["\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\n\nvar zrUtil = require(\"zrender/lib/core/util\");\n\nvar graphic = require(\"../../util/graphic\");\n\nvar AxisBuilder = require(\"./AxisBuilder\");\n\nvar AxisView = require(\"./AxisView\");\n\nvar cartesianAxisHelper = require(\"../../coord/cartesian/cartesianAxisHelper\");\n\n/*\n* Licensed to the Apache Software Foundation (ASF) under one\n* or more contributor license agreements.  See the NOTICE file\n* distributed with this work for additional information\n* regarding copyright ownership.  The ASF licenses this file\n* to you under the Apache License, Version 2.0 (the\n* \"License\"); you may not use this file except in compliance\n* with the License.  You may obtain a copy of the License at\n*\n*   http://www.apache.org/licenses/LICENSE-2.0\n*\n* Unless required by applicable law or agreed to in writing,\n* software distributed under the License is distributed on an\n* \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n* KIND, either express or implied.  See the License for the\n* specific language governing permissions and limitations\n* under the License.\n*/\nvar axisBuilderAttrs = ['axisLine', 'axisTickLabel', 'axisName'];\nvar selfBuilderAttrs = ['splitArea', 'splitLine']; // function getAlignWithLabel(model, axisModel) {\n//     var alignWithLabel = model.get('alignWithLabel');\n//     if (alignWithLabel === 'auto') {\n//         alignWithLabel = axisModel.get('axisTick.alignWithLabel');\n//     }\n//     return alignWithLabel;\n// }\n\nvar CartesianAxisView = AxisView.extend({\n  type: 'cartesianAxis',\n  axisPointerClass: 'CartesianAxisPointer',\n\n  /**\n   * @override\n   */\n  render: function (axisModel, ecModel, api, payload) {\n    this.group.removeAll();\n    var oldAxisGroup = this._axisGroup;\n    this._axisGroup = new graphic.Group();\n    this.group.add(this._axisGroup);\n\n    if (!axisModel.get('show')) {\n      return;\n    }\n\n    var gridModel = axisModel.getCoordSysModel();\n    var layout = cartesianAxisHelper.layout(gridModel, axisModel);\n    var axisBuilder = new AxisBuilder(axisModel, layout);\n    zrUtil.each(axisBuilderAttrs, axisBuilder.add, axisBuilder);\n\n    this._axisGroup.add(axisBuilder.getGroup());\n\n    zrUtil.each(selfBuilderAttrs, function (name) {\n      if (axisModel.get(name + '.show')) {\n        this['_' + name](axisModel, gridModel);\n      }\n    }, this);\n    graphic.groupTransition(oldAxisGroup, this._axisGroup, axisModel);\n    CartesianAxisView.superCall(this, 'render', axisModel, ecModel, api, payload);\n  },\n  remove: function () {\n    this._splitAreaColors = null;\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitLine: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitLineModel = axisModel.getModel('splitLine');\n    var lineStyleModel = splitLineModel.getModel('lineStyle');\n    var lineColors = lineStyleModel.get('color');\n    lineColors = zrUtil.isArray(lineColors) ? lineColors : [lineColors];\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var isHorizontal = axis.isHorizontal();\n    var lineCount = 0;\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitLineModel\n    });\n    var p1 = [];\n    var p2 = []; // Simple optimization\n    // Batching the lines if color are the same\n\n    var lineStyle = lineStyleModel.getLineStyle();\n\n    for (var i = 0; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n\n      if (isHorizontal) {\n        p1[0] = tickCoord;\n        p1[1] = gridRect.y;\n        p2[0] = tickCoord;\n        p2[1] = gridRect.y + gridRect.height;\n      } else {\n        p1[0] = gridRect.x;\n        p1[1] = tickCoord;\n        p2[0] = gridRect.x + gridRect.width;\n        p2[1] = tickCoord;\n      }\n\n      var colorIndex = lineCount++ % lineColors.length;\n      var tickValue = ticksCoords[i].tickValue;\n\n      this._axisGroup.add(new graphic.Line({\n        anid: tickValue != null ? 'line_' + ticksCoords[i].tickValue : null,\n        subPixelOptimize: true,\n        shape: {\n          x1: p1[0],\n          y1: p1[1],\n          x2: p2[0],\n          y2: p2[1]\n        },\n        style: zrUtil.defaults({\n          stroke: lineColors[colorIndex]\n        }, lineStyle),\n        silent: true\n      }));\n    }\n  },\n\n  /**\n   * @param {module:echarts/coord/cartesian/AxisModel} axisModel\n   * @param {module:echarts/coord/cartesian/GridModel} gridModel\n   * @private\n   */\n  _splitArea: function (axisModel, gridModel) {\n    var axis = axisModel.axis;\n\n    if (axis.scale.isBlank()) {\n      return;\n    }\n\n    var splitAreaModel = axisModel.getModel('splitArea');\n    var areaStyleModel = splitAreaModel.getModel('areaStyle');\n    var areaColors = areaStyleModel.get('color');\n    var gridRect = gridModel.coordinateSystem.getRect();\n    var ticksCoords = axis.getTicksCoords({\n      tickModel: splitAreaModel,\n      clamp: true\n    });\n\n    if (!ticksCoords.length) {\n      return;\n    } // For Making appropriate splitArea animation, the color and anid\n    // should be corresponding to previous one if possible.\n\n\n    var areaColorsLen = areaColors.length;\n    var lastSplitAreaColors = this._splitAreaColors;\n    var newSplitAreaColors = zrUtil.createHashMap();\n    var colorIndex = 0;\n\n    if (lastSplitAreaColors) {\n      for (var i = 0; i < ticksCoords.length; i++) {\n        var cIndex = lastSplitAreaColors.get(ticksCoords[i].tickValue);\n\n        if (cIndex != null) {\n          colorIndex = (cIndex + (areaColorsLen - 1) * i) % areaColorsLen;\n          break;\n        }\n      }\n    }\n\n    var prev = axis.toGlobalCoord(ticksCoords[0].coord);\n    var areaStyle = areaStyleModel.getAreaStyle();\n    areaColors = zrUtil.isArray(areaColors) ? areaColors : [areaColors];\n\n    for (var i = 1; i < ticksCoords.length; i++) {\n      var tickCoord = axis.toGlobalCoord(ticksCoords[i].coord);\n      var x;\n      var y;\n      var width;\n      var height;\n\n      if (axis.isHorizontal()) {\n        x = prev;\n        y = gridRect.y;\n        width = tickCoord - x;\n        height = gridRect.height;\n        prev = x + width;\n      } else {\n        x = gridRect.x;\n        y = prev;\n        width = gridRect.width;\n        height = tickCoord - y;\n        prev = y + height;\n      }\n\n      var tickValue = ticksCoords[i - 1].tickValue;\n      tickValue != null && newSplitAreaColors.set(tickValue, colorIndex);\n\n      this._axisGroup.add(new graphic.Rect({\n        anid: tickValue != null ? 'area_' + tickValue : null,\n        shape: {\n          x: x,\n          y: y,\n          width: width,\n          height: height\n        },\n        style: zrUtil.defaults({\n          fill: areaColors[colorIndex]\n        }, areaStyle),\n        silent: true\n      }));\n\n      colorIndex = (colorIndex + 1) % areaColorsLen;\n    }\n\n    this._splitAreaColors = newSplitAreaColors;\n  }\n});\nCartesianAxisView.extend({\n  type: 'xAxis'\n});\nCartesianAxisView.extend({\n  type: 'yAxis'\n});"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}